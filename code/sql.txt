一。基本概念

1.主键，外键，超键，候选键
主键：数据库表中对存储数据对象予以唯一和完整标识的数据列，不为空，不能重复
外键：在一个表中存在的另一个表的主键称为外键
超键：在关系中能唯一标识元组的属性集则称为超键
候选键：是最小超键，即没有冗余元素的超键

2.为什么选取自增列作为主键：
数字库内在结构为B树，若自增，就会自动添加到当前索引的后续位置，当一页写满，自动增添一页
否则若插入到中间位置，则需要移动数据，甚至目标页面可能已被写回磁盘清除掉，就又需要从磁盘中读回来，增加开销，还会产生大量页面碎片，造成页面的混乱

3.触发器的作用：
数据库是一种特殊的存储过程，主要通过事件的触发来执行命令，它可以强制约束，维护了数据的完整性和一致性，可以根据数据库的操作从而禁止未经许可的允许与变化

4.什么是存储过程,优缺点是什么
存储过程是一个预编译的SQL语句，在创建一次之后，代码就可以存储在数据库中，以后可以直接调用，加快了执行速度
优点：
1.存储过程是预编译过的，执行效率高
2.存储过程代码存储在数据库中，通过存储过程名直接调用，减少网络通讯以及开发人员的工作量
3.安全性高，执行存储过程需要拥有一定权限的用户
缺点：
移植性差

5.什么是视图和游标，视图的优缺点：
视图是一种虚拟表，具有和物理表相同的功能，通常是一个表或多个表的行或列的子集
游标是对查询出来的结果集作为一个单元来进行有效的处理
优点为用户通过简单查询就可以获得一般需要复杂查询才能获得的数据，且具有简单性与安全性
缺点为对视图的查询一定要转换为对表的查询，如果视图是由多个表所定义，就无法对其中数据进行更改

6.drop,truncate和delete的区别：
drop为删除掉整个表
truncate为删除表中的所有数据，且删除操作不会作为事务在日志中保存，不支持回滚操作
delete可以跟where连用，删除某一行信息，且删除操作会作为事务在日志中保存，支持回滚操作

7.什么是临时表，临时表什么时候删除：
临时表只在当前临时可见，当关闭连接时，MySQL会自动释放表并释放所有空间，也可以进行手动删除

8.关系型数据库与非关系型数据库有什么区别：
关系型数据库(MySQL)数据存储在数据表的行列中，在多表之间的复杂查询很容易实现，事务的支持也提升了数据访问的安全性，但数据存储在硬盘中，读取数据开销大
非关系型列表(NoSQL)通常存储是基于键值对的，且不需要SQL层的解析，效率高，因为基于键值对，数据间没有耦合性，非常容易扩展，但是保存在内存中，存储时间有限

9.数据库的范式与区别：
第一范式：数据表中每一列都是不可分割的数据项
第二范式：满足第一范式，且数据表中每一列或每一个实例都能被唯一标识
第三范式：满足第二范式，且数据表中每一个非主属性都不可以依赖其他非主属性，只能依赖于主属性(学生)

10.什么是内连接，外连接，交叉连接与笛卡尔积
内连接：只有能相互匹配的行
左外连接：包括左边表的全部行，以及右表中能匹配的行
右外连接：包括右边表的全部行，以及坐标中能匹配的行
全外连接：包括左右表的全部行
交叉连接：返还两个表的笛卡尔积(左右表的所有组合，左边表行数乘右边表行数)

11.char和varchar的区别：
char的长度是不可变的，varchar的长度是可变的

12.数据库语言分为四大类：
数据查询语言 select
数据操作语言 insert
数据定义语言 create
数据控制语言 grant

13.like %与—的区别：
%表示任意多的字符，-只能表示任意的一个字符

14.count(*),count(column)的区别：
第一个对行数目进行计算，包括NULL，第二个对特定的column的行数进行运算，不包含NULL

15.最左前缀原则：最左优先
当创造 ADD INDEX lname_fname_age的多列索引，相当于创造了lname的单列索引，lnam和fname的组合索引，和三个的多列索引

16.redis和mongodb是现在常用的NoSQL(非关系型数据库)：
其中redis基于key,value存储，其底层数据结构能分为五种：
1.string 2.hash 3.list 4.set 5.zset

17.为什么redis速度快：
1.采用多路复用I/O阻塞机制
2.底层数据结构简单，操作节约时间
3.运行在内存中，速度自然快

二。索引

1.什么是索引：
索引就是数据库系统中一种排序的数据结构，通常为B或B+树，通过索引，可以快速访问需要的数据

2.索引的作用与优缺点：
索引能快速查询与更新数据表中的数据
优点：可以大大加快数据的检索速度
缺点：索引需要占额外的物理空间，并且当插入或修改数据时，维护索引需要额外的时间

3.哪些适合建立索引，哪些不适合建立索引：
适合：唯一，不为空，经常被查询的字段
不适合：很少使用，或数据值很少的列，修改性能远远大于检索性能

4.B+索引和Hash索引的区别：
Hash可以一次定位，B+需要慢慢从根节点遍历到所需要定位点
使用B+树原因：Hash占用的物理内存大，并且Hash不能进行范围查询，因为经过哈希函数后的值和哈希算法之前的值不一样

5.B树和B+的区别：
B树叶子节点指向NULL，不包含有用的信息，B+树叶子节点包含了关键字的信息，以及指向这些关键字的指针

6.为什么B+比B更适合应用中操作系统的数据库索引：
B+树内部节点相对较少，磁盘读写带价更低。B+树叶子节点有指向另一个叶子结点的指针，提高的区间的访问性能

7.聚集索引和非聚集索引的区别：
聚集索引记录了表中的排列顺序与索引中的排列顺序一致，所以查找效率快
非聚集索引指定了表中记录的逻辑顺序，但排列顺序不一定一致

8.各种索引结构
辅助索引：索引结构存储主键，根据索引找到对应主键值，再根据主键值即可得到一整行信息
聚簇索引：所有记录数据都存储与索引中
覆盖索引：一个索引包含了所有需要查询的字段的值

9.主键索引和普通索引的区别：
主键索引的叶子节点存放了整行的记录，普通索引存放了其对应的主键ID
普通索引不一定需要回表查询，可能被查询的字段是索引的一部分(覆盖索引)

三。事务

1.什么是事务：
事务对数据库中一系列的操作进行统一的回滚或提交操作，主要保证数据的完整性和一致性

2.事务的四大特性：
原子性：要不一起执行，要不一起不执行
一致性：事务开始前和结束后，数据库的完整性都不会被破坏
隔离性：不同事务之间互不干扰，同一时间，一个数据只能被一个事务所操作
持久性：事务一旦被提交，对数据的改变将会是永久性的

3.事务的常见并发问题：
脏读：事务A读取了事务B更新了的数据，若B进行了回滚操作，A读取的将会是脏数据
不可重复读：事务A多次读取一个数据，在这个过程中，事务B对数据进行了更改，将会导致事务A对数据的读取前后两次结果不一致
幻读：幻读就解决不可重复读，保证了在同一个事务里，查询的结果都是事务开始时的最初状态

4.嵌套事务：
嵌套是子事务在父事务中执行，子事务是父事务的一部分，父事务执行到子事务是会建立一个回滚点，叫save point
如果子事务回滚会发生什么：父事务回滚到save point
如果父事务回滚会发生什么：一起回滚
事务提交顺序：子事务先提交，父事务再提交

5,事务的隔离级别与应用场景：
读未提交：写数据时，只会锁住对应的行，一个事务修改数据未提交，本事务会读到未被提交的数据的脏读
不可重复读：事务B的更改会使事务A读到的值不一致
可重复读(MySQL默认)：事务A读到的值始终都是初始状态，锁定整个表
串行化：最高隔离级别，不同事务互相不会产生任何影响

四。存储引擎：

1.MYSQL常见的三种存储引擎，InnoDB,MyISAM,MEMORY的区别：
InnoDB支持事务，支持外键，MyISAM都不支持

2.MYSQL存储引擎中，InnoDB和MyISAM怎么选择：
InnoDB支持一些数据库的高级功能，如事务功能和行级锁，但MyISAM性能更优，占用空间少，只支持表级锁，两者都默认为B+索引
memory存储引擎是使用存储在内存中的数据来创建表，默认为哈希索引

五。优化：

1.查询语句不同元素的先后执行顺序：
select-from-where-group by-having-order by 

六。数据库锁：

1.mysql都有什么锁：
表级锁，不会出现死锁，开销小，加锁快，发生冲突概率高，并发度低
行级锁，会出现死锁，开销大，加锁慢，发生冲突概率低，并发度高
页面锁，会出现死锁，位于两者之间

2.什么是死锁，怎么解决：
死锁：是指两个或两个以上的线程在执行过程中，因为争夺资源而造成了互相等待的现象，造成了死锁
一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。
a.将查出死锁的线程并杀死
b.设置锁的超时时间
c.指定获取锁的顺序

3.乐观锁与悲观锁：
悲观锁：先获取锁再进行业务操作
乐观锁：先进性业务操作，不到万不得已不去拿锁
乐观锁再不发生取锁失败的情况下，开销比悲观锁小，但一旦失败回滚则开销巨大，因此适用于取锁失败概率较小的场景

七。面试题：

1.如果数据很多怎么加快搜索的速度：
加入常用的到缓存之中

2.缓存和数据库怎么保持一致：
a.查询缓存数据是否存在
b.不存在即查询数据库
c.将新数据添加到缓存同时返还结果
d.下一次访问发现缓存存在直接返还缓存数据

3.当更改数据时，先淘汰缓存，再改写数据库，下次请求直接重数据库取，然后再存在缓存中

4.缓存穿透，缓存雪崩与缓存击穿：
缓存穿透：查找一个不存在的数据时，如果存储层找不到数据则不写入缓存，这将导致每次对不存在的数据的查找，这就是去了缓存的意义，在流量大时，可能db就挂掉了
解决方法为采用布隆过滤器，将所有可能存在的数据存在一个哈希bitmap中，一个一定不存在的数据将会被拦截
缓存雪崩：在我们设计缓存时使用了相同的过期时间，导致缓存在某一时刻失效时，所有请求瞬间转到db导致雪崩
解决方法为第一使用加锁只让一个线程构建缓存，第二为过过期时间加一个随机值，使所有缓存不要在同一时间过期
缓存击穿：缓存到某个时间过期时，恰好这个时间点对这个key有大量的并发请求，这些请求发现缓存过期后，一般都会从后端db加载数据并回设到缓存，这时候，大并发的请求可能会把db压垮
解决方法为使用互斥锁，只让一个线程构建缓存，其他线程等构建缓存的线程执行完了，再从缓存中获取数据

5.b+树优于二叉树的原因：
执行一次磁盘IO(寻道时间，旋转时间，传输时间)相当浪费时间
B+树优点：数据库索引是存储在磁盘上，当表中数据量增加时，索引大小也跟着增大，但我们利用索引进行查询时，不可能把所有索引加载到内存中，只能加载一个磁盘页，
对应索引的一个节点(相当于一次磁盘IO)，而B+树由于一个节点能存储多个数据，使IO次数大大降低，虽然取得节点后对比要浪费时间，但对比是在内存中，不涉及磁盘IO，耗时可忽略不计

6.高并发问题的解决方法：
a.从代码方面考虑优化代码
b.增加服务端的网络带宽并将不同的事务类型分发多台服务器
c.使用UDP代替TCP减少单一连接的问题
d.使用redis代替关系型数据库，并将常用的数据加入缓存
e.将常用不必保证安全的数据存在客户端，减少数据量的传输
f.从硬件方面进行优化

7.关系型数据库运行时的过程：
a.连接层：接受用户传来的SQL语句并传给下一层
b.SQL层：接收上层的SQL语句并进行解析操作，得到语句执行计划，找到最小的语句执行计划并执行SQL语句，并找到获取数据的方法，交由下一层处理
c.存储引擎层：根据获取数据的方法，将数据提取出来，并重新转交给SQL层

8.数据库的四大特性：
a.数据结构化，数据之间具有联系，面向整个系统
b.数据的共享性高，冗余性低，易扩充
c.数据独立性高
d.数据由DBMS统一管理和控制

9.数据库CAP原则：
指的是在分布式系统(建立在网络上的一种软件系统)中，一致性(C),可用性(A),分区容错性(P),三个最多只能同时实现两点，不能同时实现
C：在分布式中所有的数据备份在同一时刻是否具有相同的值
A：某一结点故障后，整体是否还可用
P：分区相当于对通信时限的要求

八.Redis:

1.数据结构:
1.1 动态字符串(SDS)，可随时查看长度，且更改方便，不用重新分配内从空间大写，用free记录未使用的空间，且可以保留二进制数，因为是靠Len而不是'\0'判断是否结束
1.2 双向链表，由一个list结构,(head,tail,math,len,free,match)和一个双向链表组成
1.3 字典：其中最大的特点是采用了两大哈希表，并且在过程中不断通过rehash将一张哈希表的数据迁移到另一张表中，并同时将旧表删除，同时创建新的空表，目的是通过更改散列表长度来维持负载因子的稳定
1.4 跳跃表
1.5 set与zset
redis中每个对象包含五属性：type，encoding和ptr，refcount，lru(记录了对象最后一次被访问的时间，用于计算对象的空转时长)，一般为键指向redisobject，ptr再指向具体数据类型
type(unsigned)即为5个基本类型，使用TYPE可查看类型，使用OBJECT ENCODING可查看编码类型，每种数据类型都至少用于2种编码方式，提高了灵活性，根据不同场景设计不同的编码
在存字符串对象时，根据编码的不同，ptr指向不同的对象,整数 int，double数和字符串 embstr或raw，embstr相比raw，内存分配次数从两次变为一次，所以释放也只需释放一次
list编码可以为ziplist和linkedlist
哈希对象可以为zipllist和hashtable
集合为intest和hashtable,有序集合为ziplist和skiplist
执行命令时，会自动判断编码类型，并调用对应API，实现多态，redis还具有自动的内存回收(引用计数器实现)，对象共享(键的值指针指向同一个对象)

2..单机数据库的实现：
redisServer的结构包含了，库的数量，以及一个保留redisdb的数组
redisClient的结构包含了一个指向redisdb的指针，通过改变这个指针可以实现库的转换
redisdb的结构包含了一个指向对应字典的指针，dict，包含了一个expire的字典，记录了所有键值对的过期时间(到过期时间后，对应value直接删除)
dict结构包含一个key(动态字符串)，一个对象(type，endcoding，ptr)，ptr指向对应数据结构
其中，删除策略分为定时删除，惰性删除，定期删除(153)，当搜索从服务器，若发现过期，只要主服务器没删除，从依然能取值，保持了主从一致性，删除的键对RDB与AOF都无影响
通过notifyKeyspaceEvent，连接数据库语言(del，added)与数据库底层的操作

3.RDB持久化：
Redis提供了持久化的功能，它将自己的数据状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存在磁盘中，那么一旦服务器进程退出，数据库状态也会消失不见
RDB持久化是指在指定时间内将内存中的数据集写入磁盘，实际操作时先fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的RDB文件(具有高性能和差的缓存一致性)
save会阻塞redis服务器进程，直至RDB文件创建完毕为止，而bgsave命令(默认自动执行方式)会派生出一个子进程，然后由子进程创建RDB文件，父进程继续处理命令
RedisServer维护着一个saveparam的数组，记录了执行RDB持久化的条件(对应时间与修改次数)，还有这dirty(记录上一次save后，数据库进行了多少次的修改)，与lastsave(上一次执行的时间)
一个RDB文件结构包括，五个字节的Redis字符串，四个字节的db版本号，数据，一个字节的EOF常量和八个字节的校验和
当数据被保存在RDB文件中时，包括一个字节长的selectdb，数据库号码，键值对(TYPE，长度，键，长度，值)

4.AOF持久化：
AOF持久化以日志的形式记录服务器所处理的写和删除操作，以文本的方式记录，可以打开文件看到详细的操作记录(具有低性能，数据恢复比RDB慢，但有更高的一致性)
Resdis要求会先保存到AOF缓存区，之后再写入AOF文件，再根据appendfsync的参数选择来决定同步的时间(即保存操作)，通常选取everysec，一秒保存一次，效率和安全性的折中选择
Redis还原AOF过程：不断读写AOF中的内容，对数据库进行读写操作，从而达到还原数据库的目的
为了解决AOF文件体积膨胀的问题，redis服务器提供了AOF重写功能(在子进程中完成重写)，会创建一个新的AOF文件代替旧的，新AOF不会包含占用空间的冗余命令，但实现的数据库结果一样

5.事件：
Redis服务器是一个事件驱动程序，服务器需要文件事件和时间事件
文件事件处理器使用多路复用I/O来同时监听多个套接字，套接字会存储在队列中，等待一个个套接字上事件的处理，其客户端与服务端通信过程如下：
a.客户端向服务端发送连接请求，服务器执行连接应答处理器
b.客户端向服务端发送命令请求，服务器执行命令请求处理器
c.服务器向客户端发送命令回复，服务器执行命令回复处理器
时间事件的实现：服务器将所有时间事件都放在链表中，每当时间事件运行时，它就遍历整个链表，查找所有已到达的时间事件，实际应用类似于对数据库的日常操作与维护(清除过期键值对)
通常文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且不会发生抢占，所以可能时间事件到达时，正在执行文件事件，所以可能时间事件处理时间会比预设晚点

6.客户端：
RedisServer的结构包含了一个clients,指向一个redisClient的链表，每个redisClient指向对应的db，新增的客户端会被放到链表末尾
redisClient结构包含了一个fd属性记录socket的状态，name记录名字，输入缓冲区记录客户端要发送的命令请求，输出缓冲区记录执行命令所得的命令回复，authenticated属性记录身份验证信息

7.服务端：
一个命令从发送到完成主要包括以下步骤：
1)客户端将命令请求发送给服务器
2)服务器读取命令请求并分析出目标参数
3)命令执行器根据参数查找出命令的实现函数，然后执行实现函数并得出命令回复
4)服务器将命令回复返还给客户端

服务器从启动到能够处理客户端的命令请求需要执行以下的步骤：
1)初始化服务器状态
2)载入服务器配置
3)初始化服务器数据结构
4)还原数据库状态
5)执行事件循环

8.多机数据库实现
主从同步的过程：
1)从服务器向主服务器发送PSYNC命令
2)收到SYNC的主服务器执行BGSAVE命令，在后台生成RDB文件，并使用一个缓冲区记录从现在开始写的所有命令
3)当主服务器的BGSAVE完成后，主服务器将RDB发给从服务器，从服务器读取RDB文件，更新状态
4)主服务器将缓冲区的所有命令传给从服务器，从服务器再次更新状态(第一次同步的情况)
5)同步后，对主服务器的写操作会被记录，当再次与从服务器连接时，会直接发送断线期间的主服务器的读写操作，而不用重新发送RDB占用资源与时间(完整重同步和部分重同步)

部分重同步的实现：
1)主从数据库共同维护数据偏移量来决定传播的字节数量，并判断主从服务器是否处于一之状态
2)主服务器的复制积压缓冲区：当向主服务器执行写命令时，会同时传向复制积压缓冲区，当重新与从连接时，判断偏移量的数据是否存在于积压缓冲区中，若在，执行部分重同步，否则执行完整重同步
3)服务器的运行ID：从来判断与断开实现同步的从服务器是否相同来决定执行部分重同步还是完整重同步

主从复制时，一开始从是主的客户端，从数据库发送PING与端口信息来与主建立连接，主返还PONG,之后，在发送时，主从会互相称为对方的客户端，主发送同步数据，而从发送心跳检测以及命令丢失检测

9.sentinel：
sentinel是Redis的高可用性解决方案，由一个或多个sentinel实例组成的sentinel系统来监听一个或多个主服务器以及他们的从服务器，并在被监听的主服务器下线时，
自动将其下的某个从服务器升级为主服务器，然后由新的主服务器代替下线的主服务器执行命令

sentinel启动与执行过程：
1)初始化服务器
2)将普通redis的代码替换为sentinel专用代码
3)初始化sentinel状态
4)根据给定的配置文件，初始化sentinel监听的主从服务器列表
5)创建连向主服务器的网络连接
6)sentinel会以默认10秒一次的频率不断发送INFO命令给主和从服务器，创建命令连接和订阅连接，sentinel通过命令连接向主服务器发送请求，通过订阅连接接受指定频道信息
7)当多个sentinel监听同一个服务器时，一个sentinel发送一个信息(hello)，其他未知sentinel(包括自己)也能通过订阅连接接收到hello，而已知的sentinel之间都具有命令连接，实现信息交互，不需要订阅连接
8)sentinel以每秒一次频率发送ping命令判断是否在线，当超过一定值的sentinel都认为一个服务器下线时，这个服务器才会被认作为下线状态，增加了容错性
9)多个sentinel协商选取主sentinel，并由主sentinel在所有已下线的从服务器中选取新的主服务器

10.集群：
Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能
节点会继续用redisServer保存服务器状态，用redisClient保留客户端状态，只有在集群模式下才会用到的数据用clusterNode保存

集群实现过程：
1)客户端向节点A发送cluster meet，需要将B添加到A的集群里面
2)A为B创建一个clusterNode结构，并将这个结构添加到字节的clusterState中的Node字典中
3)A根据ip地址与端口号向B发送一条meet信息
4)B将A的clustNode添加到自己的Node字典中，并返还PONG信息(一般用于接收端返还给发送端的验证信息)
5)接到PONG后，A知道B已经接收到了meet信息，并返还一个PING信息，B收到后，已知A收到自己的PONG信息，完成握手
6)A将B的信息通过Gossip协议传播给集群中其他节点，让其他节点也与B完成握手，完成集群
7)数据库之间通过将各自clustState.slots中存储的数据相互传输，来告知其他数据库自己负责的槽的取值范围，从而达到任务的高效分配
8)当客户端向集群数据库发送命令时，接受节点会判断命令要处理的数据库键属于哪个槽(cluster.slots[i]==cluster.myself)，如果这个槽属于自己则执行，则会返还MOVE错误，指引客户端发送到正确的节点
9)当客户端请求数据时，若此时集群数据库正在迁移槽，则会返回ASK(MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施)
10)主从复制后，从和主负责相同的槽点

11.发布与订阅：
订阅：客户端可以订阅一个或多个频道，从而成为这些频道的订阅者，每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息
RedisServer.pubsub_patterns中以链表结构存储着对应的客户端与其订阅的频道

12.事务：
事务开始到结束的三个阶段：
1)事务开始
2)命令入队(用于保存一次事务的多次操作)
3)事务执行(只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务)

13.Lua脚本：
Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要
Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令
Redis 使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能

14.排序：
Redis中的sort可对列表键，集合键和有序集合键的值进行排序(对value进行排序)
SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。
在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。
如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。
当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。
当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。
当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值(get对应的值)
当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面(而不仅仅是把结果返还给客户端)

15.二进制数组：
SETBIT命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1
GETBIT命令则用于获取位数组指定偏移量上的二进制位的值
BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量
BITOP命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算

16.慢查询日志：
Redis的慢查询日志功能用于记录执行时间超过指定时长的命令
Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志
新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除

17.监视器：
客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息
当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR标识会被打开
服务器将所有监视器都记录在monitors链表中，每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器










