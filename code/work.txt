1.K值的选择：
a.手肘法：
将每个簇内质点与对应的簇内其他点的平方距离误差和称为畸变程度，当K取一个值时，畸变程度趋于稳定
b.轮廓系数：
轮廓系数为评价类的分散与密集程度的指标，选取轮廓系数最大时的k值作为最合适的k值

2.SVM优化的目标是最大化分类间隔
优点：SVM提供了一种避开高维空间的分类方法，直接使用此空间的内核函数，再利用线性可分的情况下的求解方法直接求解对应的问题，降低了高维空间的求解难度
此外，SVM是基于小样本统计，增强了泛化能力
缺点：很难求解准确的核函数，一般只能用于二分类，并对大规模样本难以训练

3.char * 和char[]的区别:
a.一个为指向字符型的指针，一个为存储多个字符型的数据结构，当使用第一个定义一个字符串时，*p指向首字符地址
b.第一个可以在堆上构建与释放
c.第一个在编译时赋值，后期不能进行改变，另一个可以改变

4.初始化列表的初始化顺序,问下列代码的输出顺序;
按private定义顺序来赋值，不定义默认为16位二进制数最大值，32767

5.讲一下指针：
指向一个目标值的地址，利用指针，能指向存储在电脑储存器另一个地方的值

6.指针和数组的区别：
a.同类型指针能相互赋值，数组只能一个个赋值或拷贝
b.数组的存储空间不是在栈上，就是在静态区上，指针可以在堆上开辟空间，也可以指向其他区域的空间
c.定义不同，第一个位指向一个类型的地址，另外一个数存储定义类型的数据结构
d.sizeof不同

7.说一下指针和引用的区别：
a.指针是一个实物对象，实际存在的，引用只是一个取地址的别名
b.指针指向值后可改变，引用不可以
c.指针可以指向NULL，引用不行
d.程序需要为指针分配内存，引用不用
e.指针编译时，在符号表上显示的地址值为指针的地址值，而引用为对应值的地址
f.引用只有一级，指针可以为多级
g.引用必须初始化，指针不用

8.一个空类有那些函数：
构造函数，析构函数，拷贝函数和赋值构造函数

9.拷贝构造函数，赋值构造函数分别什么时候调用，写一下拷贝构造函数，赋值构造函数的声明
A a；
A b=a；第一个
A c；
c=a；第二个

string(const string& a){
	store=new char[a.len];
	for(int i=0;i<a.len;i++){
	store[i]=a.store[i]; }
}

string& operator=(const string& a){
	string copy(a);
	this->len=copy.len;
	swap(this->store,copy.store);
	return *this;
}

10.讲一下TCP/IP模型,TCP协议在那一层
TCP/IP模型定义了当代网络的所有基本协议，分为应用层，传输层，网络层和网络接入层
TCP定义了面向连接的，可靠的一种传输层的通信协议，IP协议只要用与在源地址和目的地址传输数据包，他还提供了对数据大小的重组装功能已适应不同的网络环境

11.HTTP协议的头有什么，说几个常用的：
Request header:

accept:向服务端声明客户端可以接受的资源类型
accept-encoding:向服务端声明客户端可以使用的编码方法，通常为压缩方法
Cache-control:控制浏览器的缓存
cookie:告诉服务器session的信息，存储让服务器辨识用户的信息
refer：告诉服务器该页面是从哪个页面链接的

Response header:

accept-range：表明自己是否已经接受了实体的一部分
content-length:设置http实体的传输长度
content-encoding:设置数据使用的编码类型
Age/date/expire：设置响应体的寿命，创建日期和过期日期

12.Session和Cookie的区别是什么：
cookie作用于用户计算机上，用来维护计算机中的信息，直到用户删除
session称为会话信息，作用于服务器，用于访问者与网站的交互
a.cookie以文本格式存储在浏览器中，而session存储在服务端
b.cookie限制了存储量，而session无限
c.可读取cookie信息，但session不行，更加安全

13.TCP的三次握手和四次挥手，如果改成两次握手会怎么样
请求会话一次，收到回话反问一次，答复反问一次，才开始会话
如果改成两次，若出现意外情况，会使B方一直等待，浪费时间
三次握手：
客户机：我想和你连接同意吗(SYN=1)
服务机: 同意(ACK=1),我也想和你建立连接同意吗(SYN=1)
客户机: 同意(ACK=1)
断开连接为四次挥手：
-客户机：服务器，我想和你断开连接，你同意吗？（FIN=1）
-服务器：我同意（ACK=1）
-服务器：客户机，我想要和你断开连接，你同意吗？（FIN=1）
-客户机：我同意。（ACK=1）
再等待2MSL时间后就真正断开了连接：1.防止最后发送的信号丢失 2.防止失效文段出现在本文本中，使下个新连接不会出现旧字段。

14.讲一下TCP和UDP的区别，什么时候应使用哪个协议，UDP的优点是什么
TCP面向连接的，更加稳定的传输层的通信协议
UDP面向非链接的传输层的通信协议
TCP：TCP对系统资源要求更多，需要维护连接状态，但是更加稳定，基于流的
UDP：不需要维护连接状态，程序结构简单，但可能丢包，基于数据报文

15.讲一下线程与进程的区别

a.进程为资源分配最小单位，线程为资源调度最小单位
b.每个进程有独立的空间，而线程为多线程公用一个空间，所以切换线程开销更小
c.线程通信方便，公用全局变量和静态变量
d.进程更稳定，线程一个崩了就全崩了

16.线程的同步方式有哪些，什么时候使用线程，应该开多少线程，线程数量由什么因素决定

a.通过object的wait和notify
b.通过condition的await和signal
c.通过一个阻塞队列
d.通过两个阻塞队列
e.通过同步队列
f.通过callback回调
g.通过同步辅助类CountDownLatch：等需要等待的线程都进行完了，再执行这个线程
h.通过CyclicBarrier：等所有线程准备完毕进入await再一起执行

多核cpu，防止阻塞，便于建模

最佳线程数=((线程等待时间+线程CPU时间)/线程CPU时间）* CPU数目

17.写一个链表反转函数
void reverse(Node *pHead){
	Node* temp=NULL;
	Node* next=NULL;
	while(pHead!=NULL){
	   next=pHead->next;
	   pHead->next=temp;
	   temp=pHead;
	   pHead=next;
	}
	return temp;
}

18.K-折交叉验证：提高网络的准确性，选出最优的超参数与网络，有效防止过度拟合
确定可选参数的子集，对每一个子集都进行K值交叉验证，选出最合适的子集
K折交叉验证就是将所有数据分成K个子集，选取任意一个子集为训练集，剩下的训练网络，执行K次，每次测试正确率相加的平均值就是对应的K的正确率

19.malloc和new区别

a.malloc和new都在堆上分配空间，但new会自动初始化
b.malloc使函数返回void*，需要强制转换类型。new为运算符，输入数目
c.malloc开辟失败返回NULL，new会抛出异常
d.malloc通过free，new通过delete
e.malloc只有一种，new有new const new,nothrow版本的new，定位new

20.TCP拥塞机制
我们知道TCP通过一个定时器，采样了RTT(客户端到服务端往返时间)并计算RTO(重传超时时间)，但是，如果网络上的延迟突然增加，TCP面对这个问题只会重传数据，然后重传会导致网络的负担更重，导致更大的延迟与丢包，
最终导致了恶性循环，TCP拥塞机制就会用于这种情况，TCP拥塞机制用于对流量的控制，抑制发送端发送数据的速率，以便接收端来得及接收
阻塞标志：重传计时器超时，接收到三个重复确认


21.c++实现线程同步：
c++可以通过thread类实现线程同步
通过join函数或sleep可使子线程在主线程之前之前，join会造成子线程对主线程的阻塞
通过detach可使子线程重主线程中分离，彼此互不干扰
看看上面的代码发现，创建的每一个线程既没有调用pthread_join让主线程等待创建出来的线程退出以便清理其占用的栈空间，
也没有用pthread_detach让线程自动清理占用的空间。所有线程执行完后占用空间不释放，最终导致内存不足，造成了所谓的内存泄漏。

22.原子变量:
在c++11中引入了原子变量的概念，并定义了多种原子操作数据类型，例如atomic_bool,atomic_int等等，如果我们在多个线程中对这些共享资源进行操作，编译器将保持这些变量的原子性，也就是说确保任意时刻只有一个线程对这个资源进行访问，保证了共享资源的正确性，避免的锁的使用，从而提升了效率

23.智能指针：
智能指针分为auto_ptr,shared_ptr,weak_ptr,unique_ptr,其中第一个已经被c++11弃用了
为什么要使用智能指针？
众所周知，指针的内存管理非常麻烦，当new创建后，需要自己写delete语句，但是我们不能避免程序未到delete就跳转了或自动返回了，如果我们不在每一个跳转或返回之前释放资源，就会造成内存的泄露，使用智能指针就能解决这个问题，因为智能指针本身就是一个类，当超过了类的作用域，类会自己调用析构函数
智能指针的操作：

auto_ptr<Test> ptest(new Test("123"))：
1.获得原指针为 ptest.get() 2.重新指向为 ptest.reset(new Test("456")) 3.判断是否为空为ptest.get()==NULL, 4.使用release可以将指针赋值为空，但不调用析构函数释放内存，只是释放了资源

unique_ptr<Test> ptest(new Test("123"))：
1.不能直接调用拷贝函数和赋值操作(即不能指向同一个对象)，只能使用 ptest2=std::move(ptest),即一个提醒用户原来的函数已经失效; 2.增添swap可交换两个智能指针的值 3.其他于auto_ptr类似

share_ptr<Test> ptest(new Test("123"))：一个对象可被多个智能指针所共享，此时多个智能指针共同维护同一个引用计数器，当对象被再次指向时，ptest的引用计数器加1
1.当ptest2=ptest时，原指向123的智能指针所维护的引用计数器减一
ptest2重新指向ptest所指向的对象，ptest不会置NULL，ptest引用计数器加1，123对象被两个智能指针共享 2.通过ptest2.use_count()，可看出该指针的指向被几个指针共享

weak_ptr<Test> ptest(new Test("123"))：用于解决share_ptr的相互引用(计数无法下降为0)

25.vector和list：
根据笔者推断有可能是由于stl的list是双向链表，所以这种push_back会涉及到内存的分配和列表关系的维护，所以导致时间开销大。但是实际上vector频繁的push_back，会使得预留空间不够的时候，重新申请空间导致的不必要的开销。

26.全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失，起到了分类器的作用

27.
拉链法优点：
1.处理冲突简单，不同义词不会有堆积现象，平均查找长度较短
2.拉链发指针空间动态申请，适用于表长不确定的情况下
3.开放地址需要很大的装填因子(结点数和表长的比值)，容易出现空的空间
4.删除方便，开放地址法不能直接删除，会截断后面的同义词的查找路径
拉链法缺点：
指针需要额外的空间，若结点数目少，贼耗费空间

28.进程与线程的同步通信方式
进程：无名管道，有名管道，信号，信号量，共享内存，消息队列和socket
线程：互斥量，读写锁，自旋锁，线程信号，条件变量

29.TCP连接中。socket在服务端和客户端分别要做什么？
socket为套接字，为通信链的句柄，分为流式套接字，数据报套接字。原始套接字，只有对方和自己的socket连接才能传递信息
服务程序：用socket()建立套接字，调用bind()绑定ip地址与端口，将套接字置为listen()模式，不断用accept()接受连接，对于每个接受的连接，可以使用send()或recv()函数收发数据
客户端：用socket()建立套接字，然后调用connect()连接服务器，之后再调用send()和recv()收发数据

30.虚函数和纯虚函数:
虚函数可以直接使用，也可以在重载或以后以多态的形式调用，纯虚函数在基类中没有实际定义，必须在子类中加以实现，且具有纯虚函数的抽象类不能进行实例化
虚函数效率低的原因：需要一次间接寻址，一般函数在编译时能直接定位地址，虚函数需要某个指针才能定位到函数的地址

31.虚析构函数:
当使用父类指针指向子类的对象时，只会调用父类的析构函数，但若定义了父类的虚析构函数，就会同时调用子类和父类的析构函数，避免了内存的泄露

32：哈希表的长度取决于散列函数和冲突解决的策略，一般最合理的为存在键数的1.3倍，哈希表长度等于元素个数/装填因子

33.extern放在函数或变量之前时，表示变量或函数的定义在别的文件中，提示编译器遇到此模块时在别的模块中寻找其定义
extern c与c连用时告诉编译器用C的规则去翻译
static只在本文件中使用
extern可被其他文件使用
一个被定义了volatile的变量相当于告诉这个编译器变量经常会被意想不到的改变，当使用这个变量时，必须从它对应的地址中读取信息，而不是使用保留在寄存器中的备份，从而保证不同线程看到的值相同

34.僵尸进程:如果子进程比父进程先结束，但父进程却没有及时回收子进程，造成了资源的泄露，此时子进程就成了一个僵尸进程
解决方式：父进程调用wait将自己阻塞来获取子进程的终止状态
用signal通知内核，并让内核对其进行回收
孤儿进程：子进程未结束，父进程异常退出，子进程变成孤儿，init进程会认做它的父进程
守护进程：就是init进程，负责监控各个进程状态，执行认儿子，杀死父进程等操作，此种进程可以没有线程

35.自旋锁与互斥锁都可用来通知多线程，每次只有一个线程能对此变量进行操作，区别是，互斥锁为锁定其他的互斥量，其他互斥量睡眠等待被唤醒，使用自旋锁，其他线程保并不会睡眠等待，而是不停的循环检测保持者是否已经释放了锁

36.ResNet:
网络深度越高，对特征的的表达能力越高，如果不考虑梯度弥散或爆炸(每次更新w，在输入经过多次sigmoid输出后，梯度的变化会变得微乎其微，使网络无法训练，解决方法为用relu作激活函数)，准确率将会越高
一个方面，改变成计算FX的值，当网络特征达到optimal时，即浅层的输出足够成熟，FX自动退化成0，能够实现恒等映射的作用
残差块的值会减小模块中参数的值，从而使网络堆反向传播的损失具有更加敏感的响应作用
因为有恒等映射支路的存在，反向传播中梯度的传到也变得更为快捷，仅仅通过relu一个激活函数，就可把梯度传给上一个模块
但太深也不行，残差模块在加后需要一个激活函数，当层数过多时，会阻碍整个网络的反向传播
如果在该 2 层网络中，最优的输出就是输入 x，那么对于没有 shortcut connection 的网络，就需要将其优化成 H(x)=x；对于有 shortcut connection 的网络，即残差块，如果最优输出是 x，则只需要将 F(x)=H(x)−x 优化为 0 即可。后者的优化会比前者简单。这也是残差这一叫法的由来。

37.
void* _memcpy(void* dest, const void* src, size_t count)
{
	assert(src != nullptr&&dest != nullptr);
	char* tmp_dest = (char*)dest;
	const char* tmp_src = (const char*)src;
	while (count--)
		*tmp_dest++ = *tmp_src++;
	return dest;
}

void* _memmove(void* dest, const void* src, size_t count)
{
	assert(src != nullptr&&dest != nullptr);
	char* tmp_dest = (char*)dest;
	const char* tmp_src = (const char*)src;
	if (tmp_src > tmp_dest)//当src地址大于dest地址时，从头进行拷贝
		while (count--)
			*tmp_dest++ = *tmp_src++;
	else if (tmp_src > tmp_dest)//当src地址小于dest地址时，从后进行拷贝
	{
		tmp_src += count - 1;
		tmp_dest += count - 1;
		while (count--)
			*tmp_dest-- = *tmp_src--;
	}
	else(tmp_src==tmp_dest) //此时不进行任何操作
	return dest;
}

38.常用的网络通信模型：
阻塞I/O,非阻塞I/O,多路复用I/O：
阻塞I/O(IO)：当调用read,如果没有数据收到，线程或进程就会被挂起，处于持续等待状态
非阻塞I/O(NIO)：当调用read，如果没有数据收到，线程或进程会报错，提示你等等再来检查
多路复用I/O：使用一个线程来检查多个文件描述符(socket)的就绪状态,(利用select,poll,epoll)，只要有一个文件描述符就绪，它就可以返回，并通知用户进程，否则阻塞知道超时
其中select,poll和epoll都是同步I/0，即每次事件就绪后，都需要自己进行读写，而异步I/O无需自己读写，异步I/O会自己把数据从内核拷贝到用户空间

39.gdb:
如何查看某个线程: info thread
如何设置断点:break n
如何使程序继续运行，直至遇到断点：c
程序开始执行：run
跳入下一个点：jump
寄存器信息： info reg
堆栈使用情况： info stack
gbd app
run 在gbd中启动程序
start 停留在main函数
step 下一步
next 下一步，可进入函数内部，不包括库函数
quit 结束gbd
break 10 设置第10行为断点
info break 查看断点
delete 删除断点
continue 运行直至下一个断点
jump 跳转至下个断点



40.内存耗用:
VSS:虚拟内存
RSS:实际使用物理内存(进程占用内存)，包括共享库内存
PSS:实际使用的物理内存，但共享库内存按照线程数进行了划分
USS:进程独占内存
c++进程地址空间从上到下划分：内核，栈，共享库，堆，未初始化，初始化，程序页
未初始化是在编译期间没有明确初始值的全局或静态变量，而初始化是在编译期间明确了初始值的全局或静态变量

41.C4.5	决策树：
以信息增益率代替了信息增益成为了树枝的划分条件
寻找每个非叶子节点的损失函数减小程度，选取最小的进行剪枝，得到n个不同的剪枝树，使用交叉验证，选取最优子树
剪枝的目的并不是为了最小化损失函数，而是为了增加泛性，损失函数越小，越准确，泛性越弱

42.
select、poll、epoll之间的区别
select:O(n) 无差别查询所有数据流，会受最大连接数的限制
poll:与select相似，但poll使用链表来进行文件描述符的存储，不会受到最大连接数的限制
epoll:O(1) epoll会把，哪个流发生了怎样的I/O事件通知给我们，分为水平触发(LT)和边缘触发(ET)
水平触发为允许在任意时间重复检查io状态触并不断通知，而边缘触发在出现io时间时之后提醒一次，直至出现新的io

43.this指针：
1.this指针本质上是一个函数的参数，只不过在编译器隐藏起来了，只能在成员函数中使用
2.this在成员函数开始前构造，在结束后自动删除
3.this指针不占用对象的空间
成员函数不占用类的空间，函数放在代码段中，所有对象共用一份函数代码

44.ifndef/define/endif的作用：
防止头文件被重复的使用或定义

45.c和c++：
C主要考虑通过一个过程将输入进行各种运算后得到输出，C++主要考虑的是如何构造一个对象模型

46.堆栈溢出原因：数组越界，死循环，没有回收内存，深层次递归调用

47.普通局部变量与局部静态变量的区别：
1.普通局部变量是执行到定义语句才会分配空间，static在编译期分配空间
2.普通局部变量在离开对应作用域释放，第二个在整个函数结束后才会释放
3.普通局部变量不初始化为随机值，另一个为0

48.内联函数和宏的区别：
内联函数若系统判定为可以内联，他就会在编译阶段直接展开并镶嵌到代码之中。
宏不是函数，他只是在编译期预处理阶段将函数中对应的字符串替换成了宏体
const相比于宏，前者可以定义数据类型，更加安全，而后者不行，但后者在运行时不必分配内存

49.快慢链表：
1.判断是否有环：在NULL之前判断快慢指针是否相遇
2.判断环长度:碰撞点慢指针所经过的节点数即为环长度
3.判断环的连接点，速度相同的指针分别从碰撞点与头节点遍历，相遇点即为连接点
慢指针在环内走的节点数为x-y，所以再走y即为一个环，为环入口，快刚好再走y也到环入口，所以下次相遇就是开始点

50.
重载为函数名相同，参数类型，数量不同，与多态(重写和template)无关，重写才与多态有关，分为静态多态与动态多态

51.拷贝构造函数和赋值函数：
浅拷贝：只是拷贝了一份指针指向已存在的内存地址，一方改变，另外一方跟着改变
深拷贝：创造一个和原来一摸一摸的对象，新旧对象不共享地址
拷贝构造函数：对象不存在，且用别的对象对其进行初始化。在不自己定义时，会默认为浅拷贝(同一片内存会被释放两次，会导致程序崩溃)，需要自己进行重载成深拷贝(完成独立成两个对象，指向不同的地址)
赋值函数：对象已经存在，且用别的对象对其进行赋值。

52：设计模式是一套经过反复调用与实验的代码设计经验的总结
单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点
实现过程为构私有构造函数，提供一个私有静态对象，提供一个共有静态方法，返还该对象
优点为，可保证所有对象都访问唯一实例，并且类可灵活更改实例化过程，缺点为开销大，每次对象请求都要检测是否存在类的实例
饿汉式在类加载时创建对象，浪费内存但调用效率高，懒汉式在类访问时才创建对象，节省内存但调用效率低，且饿汉式具有同步锁，执行效率高于懒汉式

工厂模式：定义了一个创建对象的方式来代替new，过程为首先定义一个父类的接口，然后根据具体情况实例化哪个子类
主要用于解决对象产生过多，或经常有子类替换生成的现象
简单工厂是静态方法，实现了对象创建和使用的分离，缺点是当添加新类时，需要对简单工厂进行修改，违背了开放封闭的原则，不利于扩展与维护
抽象工厂是动态方法，提供一个创建一系列相关对象的接口，而无需指定具体的类，优点为，解决了简单工厂的缺点，易扩展，但却工厂个数过多导致系统庞大，消耗内存

53：STL主要包括三部分，容器，算法和迭代器：
容器分为序列式容器(list,vector)和关联式容器(tree,map,hashmap)
算法一般为排序，查找，最短路径
迭代器提供了一种方法，使它能够给顺序访问某个容器所包含的所有元素，但无需暴露该容器的内部结构

54.strstr(str1,str2)判断str2是否为str1的子串，并返还str1中第一次出现str2的地址,&str1[i],strcat(str1,str2)为将str2补充到str1的后面

55.strcpy与memcpy的不同：
1.复制内容不同，strcpy只能作用于字符串，而memcpy能作用于任何数据类型
2.strcpy他遇到被复制的字符串的'\0'才结束，所用容易溢出，memcpy则是根据第三个参数决定
3.用处不同，一般字符串用strcpy，其他类型用memcpy

56.i++是否为原子操作：
在多线程中，不能被其他线程打断的操作就叫做原子操作
i++分为三个阶段：内存到寄存器，寄存器自增，写回内存，这三个阶段都可以被其他线程打断或分离开

57.c++的四种强制类型转换：
static_cast:可以实现基本数据类型的转换
const_cast:可以将不是const的数据类型转换成const
reinterpret_cast:可以进行任意数据类型的转换，但不考虑安全情况
dynamic_cast:
1.在运行时完成，其他都在编译时完成，运行时要进行类型检查
2.不能用于内置的基本的数据类型的转换
3.成功转换后返还指向类的指针与引用，转换失败会返还NULL
4.转换基类一定要有虚函数，不然失败
5.一般用于父类到子类的转换，有自动检查功能，安全

58.#pragma pack(n)可设置字节对齐方式，n为字节对齐数

59.auto_ptr缺陷：
1.两个智能指针不能指向一个对象
2.auto_ptr不能管理对象数组，因为析构函数是delete而不是delete[]
3.auto_ptr不能作为容器对象，因为在容器拷贝赋值等操作中，在这过程中auto_ptr会传送所有权

60.epoll优于select的原因：
1.select,poll,epoll都会返还就绪的文件描述符的数量，但select和poll并不会明确指出那些文件描述符已经就绪了，需要从头遍历一次，而epoll则会将就绪文件存入对应数组，所以不需要遍历
2.select,poll都需要将有关文件描述符的数据结构拷贝进内核(内存是内核的一部分)，然后再拷贝出来，而epoll创建的有关描述符的数据结构本来就存储在内核之中，系统调用返还也是采用mmap共享内存区，需要拷贝次数大大减小
3.一般在连接较多(描述符多)的情况下，epoll更高效，因为select每次使用都要重置描述符数据结构并传给内核，遍历查找就绪的描述符，而当连接数较少时，维护红黑树将会得不偿失，而select遍历的时间将会大大减少

61.TCP保证安全性与可靠性的两个协议(具体是由滑动窗口实现)：
停止等待协议：每发送一个分组，等待对方确认，确认后再发
连续ARQ协议：利用滑动窗口，滑动窗口内的所有分组都可以连续地发送出去，而不需要逐个等待对方确认，只对按顺序到达的最后一个分组进行确认，表示这个分组之前的所有分组都已经接受到了

62.TCP什么时候会发送复位包：
连接到一个端口时，该端口上没有正在监听的服务
检测到不存在的端口的连接请求
接受数据超时，会发送复位包

63.TCP心跳包机制：
每隔一段时间就发送一个自定义的结构体(心跳包或心跳帧)来让对方知道自己在线，以保证链接的有效性

64.虚拟内存地址和物理内存地址的转换：
用分页的方式来记录虚拟地址和物理内存地址一一对应的关系，从而进行正确的地址转换

65.为什么需要进程，进程间的切换是怎么实现的：
当一个程序运行时，无法了解内部的具体情况，因而引入进程，来对运行中的程序进行显示
进程切换的四个步骤：
1.决定是否做上下文切换，以及是否允许上下文切换
2.保存当前执行进程的上下文，并将此进程挂起
3.使用进程调度算法，选择处于就绪状态的进程
4.恢复所选进程的上下文，将CPU控制权交到此进程手中，实现进程切换

66.主从复制：
master中的bin-log文件用于记录数据库的更新，slave数据库始终监测master数据库，若有更新，则解析master数据库中bin-log中的sql语句，并在slave上执行

67.TCP滑动窗口的功能：
tcp应用滑动窗口来实现流量的控制
ACK机制：假设一开始不知道接收方窗口大小，发送方窗口大小为3，首先发了序列号1，2，3三个信号，接收方发送ACK3，表示需要3号信号，意味着接收方窗口大小只有2，所以3号信号没收到，
发送方就把窗口变为2，这就是滑动串口的机制，当链路变好或变差，窗口大小会发生改变，不是第一次协商后，窗口大小就永远不变的，当需要结束时，接收方返还ACK0

68.Time wait与close wait：
Time wait是主动关闭时形成的，主要为了防止最后一个ACK的丢失
close wait是被动关闭时形成的，服务端接收到FIN，则按照规定发送ACK，因此进入close wait状态，需要使用close()释放

69.tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析

70.c++从源代码到生成可执行程序的过程：
源代码，预处理，编译，优化，汇编，链接，可执行文件

71.http和https的区别：
http是一种网络协议，它提供了一种接受和发布html页面的方法
https即为http加了一层ssl(用于对http传输的数据加密)，增加了安全性
ssl协议过程：
1.客户端向服务端发送请求建立ssl连接
2.服务端收到请求后，向客户端作出回应，并发送服务端的证书信息(公钥存储在证书信息中)
3.客户端收到回应后，验证服务器证书，并与服务端协商信息加密的等级，产生随机对称密钥
4.客户端用公钥对对称密钥进行加密，然后传送给服务端，服务端用私钥解密出会话密钥
5.客户端与服务端之间即可用会话密钥对信息进行加密并传输

72.浏览器访问一个域名的全过程：
域名解析，三次握手，发送和接受数据，四次挥手

73.ARP攻击与防止：
ARP为地址解析协议，负责将某个IP地址转换成对应的MAC地址
ARP病毒攻击时常见的一种攻击方式，它会持续向所有计算机的通信网络发送大量的ARP欺骗数据包，造成网络堵塞，影响通信质量
防护方法：
不要单纯将信任建立在IP与MAC基础上，可以假设DHCP服务器，绑定网关，IP与MAC，或者停止使用ARP

74.进程退出之后将不存在内存泄露的现象，因为内核和自动将进程申请的内存释放

75.epoll底层实现：
一个红黑树和一个就绪链表，当红黑树检测到新的文件描述符并插入节点时，并且告知内核注册回调函数，当接收到某个文件描述符发来数据时，就将该文件描述符插入到链表中

76.子进程fork(复制)父进程：
数据类型为全局变量，堆，栈都不共享，当数据类型为文件时才共享

77.MTU：
MTU限制了传输的最大帧长度，所以当ip数据报超过MTU时，ip数据报必须经过分片处理，而tcp则会自己进行长度的安排

78.静态链接与动态链接的区别：
静态链接的过程已经把需要链接的内容已经链接到了可执行文件中，就算把静态库删除，也不会影响可执行文件的运行，优点为执行速度块
动态链接却没有把内容链接到可执行文件中，而是在执行过程中，再对需要链接的目标文件进行链接，所以删除静态库会影响可执行文件的运行，优点为占用内存小
所以总的来说动态链接的可执行文件要相对小些
静态库可放在任何目录下，只要链接一次，以后直接使用绝对路径去链接就可以了

79.计算机存储体系分类：
内存：容量小，速度快，稳定性不高(当系统的物理内存不够的时候，就需要将物理内存中的一部分释放出来，这时就可以使用虚拟内存)
外存：容量大，速度慢，稳定性高
高速缓存：当CPU要从内存中获取指令时，将同时在高速缓存中运行，当在高速缓存中找到目标数据时，就停止在内存中的访问，大大提高了CPU的利用率
寄存器：用来暂时存放参与运算的数据和运算结果

80.内存池与对象池：
内存池：内存池是在真正使用内存之前先申请数量，大小相等的内存块作为备用，当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再申请信内存。
优点为使得内存分配的效率得到了显著的提升
对象池：对象池的基本原理有两点：缓存和共享，即对于频繁使用的对象，在使用完后，不立即将他们释放，而是将他们缓存起来，以后后续的应用程序重复使用
优点为减小对象的创建和释放次数，改善了应用程序的性能。事实上，对象池将对象限制在一定数量，减少了内存的开销

81.<>和""的区别：
<>引用的是编译器的类库路径的头文件，""引用的是程序目录的相对路径中的头文件

82..cpp与.c的区别：
gcc认为.c是c的程序源码，.cpp是c++的程序源码
g++认为.c和.cpp都是c++程序的源码

83.回调函数：
当把一个指向函数的指针作为参数传递给另一个函数时，当这个指针被用来调用其指向的函数时，我们就说这是回调函数

84.可重入函数和不可重入函数：
在实际系统设计中，经常会出现多个任务调用同一个函数的情况，如果这个函数是不可重入的，那么不同任务在调用这个函数时，可能修改其他任务调用这个函数的数据
所谓可重入，是指一个可以同时被多个任务调用的过程，且任务在调用时不必担心数据是否会出错
满足下列条件是不可重入的：
1.函数中使用了静态结构体
2.函数类调用了malloc函数
3.函数内调用了标准的I/O函数

85.互斥是指两个线程互相排斥不可同时运行，必须等待其中一个运行完毕，另一个才运行，同步是一种特殊的互斥，指两个线程必须按某种特定的顺序来运行

86.红黑树与AVL(平衡二叉查找树)的区别：
红黑不像AVL追求完全的平衡，所以提出了红黑节点的规则，只追求部分的平衡，任何的不平衡都会在三次旋转内解决，而AVL是严格平衡二叉树，在增删节点时，旋转次数要比红黑树多
插入节点失衡的情况下，红黑树与AVL都是通过两次旋转调整的，旋转的量级都为O(1)
删除节点失衡的情况下，AVL需要维护从被删除点到根节点上所有节点的平衡，旋转的两级为O(logn)，而红黑树最多只需旋转三次
综合所属，红黑树查找弱于AVL，调整优于AVL，综合实力强

87.sleep，wait，yield的区别：
sleep：使当前执行的线程暂停执行，不会释放锁，进入阻塞状态，不会释放CPU权限
wait：与notify连用，使该线程等待并释放锁，使其他线程能抢到锁
yield：让线程重新进行到可执行状态而不是阻塞状态，它只需要重新等待CPU分配的时间

88.线程的五个状态：新建状态，就绪状态(调用start处于就绪状态)，运行状态(调用run处于运行状态)，阻塞状态，死亡状态

89.阻塞的三种情况：
1.等待阻塞：调用wait的方法后进入等待阻塞，只能通过notify唤醒
2.同步阻塞：运行的线程在获取对象的同步锁时，若该锁被占用，JVM会把该线程放入锁池中，进入阻塞状态(锁池的对象可以竞争锁)
3.其他阻塞：调用sleep或join，JVM就会把对应线程设为阻塞状态

90.实现可见性(一个线程修改一个共享变量后，其他线程能立刻看到修改的结果)的方法：
利用synchronized或者lock，来保证同一时间只有一个线程获取锁执行代码
sychronized和lock的区别：sychronized发生异常会自动释放锁，不会发生死锁，而lock需要unlock来释放，sychronized采用悲观锁机制，lock采用乐观锁机制

91.实现LRU(最近最少使用)的三种方法：
1.数组记录出现的时间，如果再次出现，时间归零，当数组空间满时，把时间最大的消除(插入，删除复杂度为n)
2.链表记录出现的节点，若再次出现，则把出现过的节点移至表头，当空间满时，把链尾元素删除(定位元素复杂度为n)
3.利用linkedhashmap(双向链表加哈希表)，当数据再出现时，把出现节点移至表头，当空间满时，将链尾节点删除(插入，定位复杂度皆为1)
其中，LFU为最少频率使用，FIFO为先进先出

92.JVM：
JVM为java虚拟机，java源文件经过编译成字节码程序，通过JVM将每一条指令翻译成不同平台的机器码，通过指定平台运行
JVM内存分为方法区，堆区(往高地址方向)，程序计数器，虚拟机栈和本地栈(往低地址方向)，其中方法区和堆区为线程共享，其他为不共线

93.
背包：for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= C; j++)
		{
			if (j < w[i])			
			{
				V[i][j] = V[i-1][j];
			}
			else               //只要这个物品的重量小于背包的容量就有可以放进去进行比较的资格
			{
				V[i][j] = max(V[i-1][j], V[i-1][j - w[i]] + v[i]);
			}
		}
	}


硬币：
dp[0]=1;
for(int i=0;i<len;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j] += dp[j-coins[i]];  //当前金额的组合数量
            }
        }

94.常用的GC(垃圾回收)算法：
a.引用计数法：给每个对象一个引用计数器，每当一个被引用，计数器加1，失效减1，当为0时不可再被使用
优点：及时回收，不必沿着链表查找   缺点：计数器增减处理任务繁重，实现繁琐
b.标记清除法：把所有活动对象都作上标记，将没标记的对象进项清除回收
优点：实现简单  缺点：在回收过程中会产生分块碎片，导致后面内存无法分配
c.复制算法：当一块内存使用完后，将还在活动的对象复制到另一片内存，回收一使用过的内存
优点：优秀吞吐量且不会碎片化  缺点：堆的使用率低下且复制浪费时间
d.标记压缩算法：与标记清除法类似，但后续要将活动对象移动到另一端并直接清除掉端边界以外的内存
优点：可有效利用堆  缺点：压缩浪费时间

95.垃圾回收器：
Serial收集器：采用复制算法，单线程收集，当收集时必须暂停所有工作线程，但却简单高效
ParNew收集器：serial的多线程版本，多CPU表现出色，与CMS收集器配合工作
CMS收集器：是一种获取最短回收停顿时间的收集器，使用标记清除算法，并发收集效率高，但却需要更多内存，使用用户交互较多的场景

96.vector支持线程同步但却效率低下，因为加了synchronized，而arraylist不支持
要想arraylist线程安全，可以使用collections.sychronizedlist，其原理就是除了迭代器，各种操作都加了关键字synchronized

97：拥塞避免机制：
拥塞避免机制是指通过监视网络资源的使用情况，在网络尚未发生严重过载的情况下，主动采取丢弃报文的策略来减少负担
尾丢弃：划分红黄绿三种报文，那种超过对应丢弃阈值就丢弃
加权随机早期检测：观察队列占用率，在低限与高限之间随即丢弃，超过高限全部丢弃

98.CPU上下文切换：
上下文切换有时也称作进程切换或任务切换，是指CPU从一个进程切换到另一个进程
自愿上下文切换：是指当前进程无法获取所需要的资源，导致上下文的切换
非自愿上下文切换：是指进程到了等待的时间被系统强制进行上下文的切换

99.UDP如何实现可靠性传输：
TCP维持传输可靠性凭借三大要素：确认机制，重传机制，滑动窗口
而UDP需要再传输层实现这三大要素，目前有RUDP，RTP，UDT

100.get和post使http与服务器交互的方式，其两者有如下区别:
a.get把请求的数据放在url上(即http协议头上)，是不安全的，而post把数据放在http的包体内，是安全的
b.get传输数据量小，主要受到url长度控制，post传输数据量大
c.get执行效率比post好，get是form默认的提交方法
d.get是向服务端请求数据的，一般为get一个html界面，而post是向服务端提交数据的，一般会发出一个post请求提交一个表单来请求服务器做一件事

101.同步与异步：
所谓同步，就是发送一个功能调用时，在没有得到结果前，该调用就不会返回或执行后续的操作
所谓异步，就是发送一个功能调用时，在没有得到结果之前就可以执行后续的操作

102.线程安全是多线程编码的一个概念，在拥有共享数据的情况下，线程安全的代码会通过同步机制来保证各个线程的安全性。其安全状态能分为五类
a.不可变类：一个不可变类只要构建正确，其外部可见状态永远不会改变，永远不会看到不一致的状态
b.线程安全类：任何操作都不会影响该类的所有不可变量，前置条件或后置条件
c.有条件的线程安全类：单独操作是安全的，但外部同步不一定安全
d.线程兼容类：线程兼容类为不安全的，但可通过同步使其安全的使用
e.线程对立类：不管是否调用外部同步，都不能在并发情况下保证其安全

103.http的工作原理：
a.http客户端(通常为浏览器)向DNS发送请求，根据URL中的域名解析出对应的ip地址，根据该ip地址与默认端口与服务端http端口建立一个TCP套接字连接
b.通过TCP套接字，客户端向服务端发送一个文本的请求报文，一个报文包括请求行，请求头部，空行和响应数据四部分
c.服务端解析请求，定位资源，并通过TCP返还一个响应，响应包括状态行，消息报头，空行和响应正文组成
d.客户端接收后四次挥手关闭TCP连接
e.客户端解析html内容并在网页上进行显示


104.http登录界面并对界面修改的过程：
a.在客户端输入账号密码之后，与服务端建立连接，服务端验证账户密码成功后，会返还登录成功后的界面，并提醒session将数据进行更改(比如用户名)并返还一个session id存储在cookie
b.接着用户若要进行文章发表或更改操作操作，客户端会发送一个请求，这个请求包括了cookie中的session id
c.服务端对session id进行解析，查找有无对应的session内容，若有则将session内的值进行反序列化读取到了用户的id，并在CMS数据库中进行插入或修改，并返还http响应，告诉浏览器操作成功

105.CPU是电脑的处理器，是大脑和核心，内核是CPU的核心部分，可以具有多内核，内存和硬盘都是存储器，受CPU的指挥
cpu工作的时候：1.从硬盘中提取数据 2.在内存(内存比硬盘速度快)中进行运算和操作 3.计算出结果在返回到硬盘存储器

106.无名管道与有名管道的联系与区别：
联系：通信数据只存在于内存缓冲页面中，都是半双工通信
区别：无名管道只能用于子进程与父进程之间的通信，而有名信道可用于任意两个进程之间的通信

107.点乘和叉乘：
点乘也被称作向量的内积，其几何意义是一条边向另一条边的投影乘以另一条边的长度，为标量 a*b=|a||b|cosθ
叉乘的几何意义为向量a和向量b构成的平行四边形的面积，为向量，模为 a*b=|a||b|sinθ，方向用右手准则判断

108.线程池可能遇到的问题与解决方案(newCachedThreadPool)：
简单线程池可能会遇到一些问题，比如线程池的工作线程是有限的，服务器只能为部分客户提供服务，为了解决这一问题，调整并优化线程池的尺寸是现在要解决的问题
a.创建一个动态的线程池
b.根据统计学统计人数并设计平衡线程池
c.一个服务器提供多个线程池
应用范围：1.任务时间短，数量多 2.对性能要求苛刻的应用 3.突发性有大量请求的情况

109.动态求最大连续子序列和：

dp[0]=store[0];
for(int i=1;i<store.size();i++){
	dp[i]=max(store[i],dp[i-1]+store[i]);
}
int res=0;
for(int i=0;i<store.size();i++){
	res=max(res,dp[i]);
}
return res;

110.过程与对象
面向过程就是分析解决问题所需要的步骤，然后把这些步骤一步步实现
面向对象是把构成问题事务分成各个对象，建立对象的目的不是为了完成某一步骤，而是为了描绘某个对象在整个问题解决步骤中的行为

111.线性回归与深度学习中的参数调整：
a.学习效率
b.网络层数
c.每层的节点数
d.batch size(batch size决定的是梯度下降的方向，分为batch gradient desecent,Stochastic Gradient Descent与Mini-batch Gradient Decent),一般batch size越大，收敛的越快
e.迭代次数(不一定能保证一定收敛，所以设置最大的迭代次数)
f.sigmoid参数(该参数调整激励函数的形式)
g.误差系数

112.虚表：
具有虚函数的类具有虚表，虚表为指向虚函数的指针，当子类重写时，子类也会有自己的虚表，子类的虚表指向父类的虚函数，从而实现对父类虚函数的重写
每次创建一个虚类时，都会创造一个虚表指针，从而实现对虚表(指针数组)指向的虚函数进行调用

113.空洞卷积：
感受野就是卷积神经网络的每一层的特征图上的像素点在原图像上映射的大小。空洞卷积与普通卷积的卷积核大小一样，但空洞卷积具有更大的感受野

114.七层协议与五层协议：
OSI七层协议：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层
TCP/IP四层协议：应用层，传输层，网络层，网络接入层
五层协议：应用层，传输层，网络层，数据链路层，物理层

115.DNS工作过程：
当应用过程需要将一个主机域名映射为IP地址时，就调用域名解析函数，解析函数可将待转换的域名放在DNS请求中，以UDP报名方式发送给本地域名服务器。
本地的域名服务器接收到域名后，将对应的IP地址放在应答报文中进行返还

116.
非抢占式优先权算法：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统
抢占式优先权调度算法：逻辑上允许正在执行的进程暂停的调度方式，(当有执行级更高的进程时，允许重新分配处理器)可防止单一进程长时间独占CPU，但系统开销大

117.进程的优先级反转：
低优先级的任务先于高优先级的任务执行了，优先级搞反了
假设三个任务优先级A>B>C,C先执行，此时，A开始，则C转为就绪状态，A转为运行状态，A执行过程中需要使用某个资源，而这个资源又是C独有，于是A进入阻塞，C转为运行
此时，若B开始，C会转为就绪状态，B转为运行状态，结果会导致B早于A执行完成
解决方案：
1.当高优先级资源被低优先级占有而阻塞时，提高占有资源的任务的优先级
2.谁先拿到资源，就将该任务提升到该资源的天花板优先级(区别为，无论是否发生阻塞，都会进行优先级的提升)

118.滑动窗口与拥塞控制的关系与其区别：
滑动窗口通过接收方的通知来控制发送端窗口的大小，而拥塞窗口用于控制全局网络的拥塞情况。
如果没有拥塞控制，那么每台主机每次发送方每次发送的数据都为滑动窗口的大小，那么整个网络系统必然会瘫痪，所以在 发送方通过设置拥塞窗口，可以有效缓解网络压力

119.keep-alive头的作用：
一般模式为非keep-alive模式，每次进行请求都要建立客户端与服务端的连接，完成之后立刻断开连接。
当使用keep-alive模式时，会使客户端到服务端的连接持续有效，当出现对服务器的后继请求时，避免了重新建立连接
而keepalive原理为TCP连接时每隔一段都会发送心跳包来保证彼此的在线

120.双向链表的翻转
while(p!=NULL){
	Node *temp=p->pre;
	p->pre=p->next;
	p->next=temp;
	if(p->pre==NULL) break;
	else p=p->pre;
}
return p;

121.虚继承：
当B,C继承A类，D继承B,C类，这时就需要将B,C对A的继承改成虚继承，来防止D类中出现两份A类成员，c++在对D实例化时，只调用一次虚基类的构造函数，而忽略B,C对虚基类构造函数的调用

122.抢占式内核与非抢占式：
抢占式：当进程位于内核空间内时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可将当前进程挂起，执行优先级更高的进程
非抢占式：高优先级的进程不能中止正在内核中运行的低优先级的进程

122.线程与协程的区别：
a.协程是一种用户态的轻量级线程，是非抢占式，协程的调度完全由用户控制
b.线程进程都是同步机制，而协程是异步机制
c.协程能保留上一次运行的一个状态，每一次重入过程时，就相当进入到上一次调用的状态

123.信息增益与信息增益率：
信息增益率=信息增益/分裂信息度量
简单来说分类信息度量是对信息增益率按照条件的个数与比重进行了缩放处理

123.勾选了is trigger即为不做物体碰撞受力，若要产生效果，两方都必须加刚体和碰撞器
Collision碰撞：两个都不能勾选trigger，即又要发生物理碰撞受力，又要产生效果的情况
Trigger碰撞：至少有一方勾选了trigger

124.多线程比进程快的原因：
a.多线程编程的目的主要是为了最大化利用CPU的资源，当某一线程的处理不需要占用CPU而只需与I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源
比如群发email的情况，由于操作一次需要网络返还信息等待的时间比较长，而对CPU时空闲的，如果顺序执行发送，就需要花费很多时间，但多线程就可在等待期间进行其他的操作
b.上下文切换快：不需要切换内存空间
c.共享虚拟内存，实现多线程占用的内存小
d.一个线程挂掉，整个进程挂掉，而多进程不受影响，且多线程实现同步要不停的检验锁，实现困难

125.迭代器失效的几种情况：
a.对于序列式容器(如vector)，删除当前的iterator会使后续的iterator都失效
b.对于链表式容器，删除运算会使指向删除位置的iterator失效
c.对于关联容器式(如map,set)，删除当前iterator会使当前的iterator失效
d.越界也会产生迭代器的失效

126.寄存器的种类：
a.通用寄存器:一般用来存16位的数据或地址
b.指针和变址寄存器：一般存放某一段内地址的偏移量，主要在堆栈操作和变址过程中使用
c.段寄存器：存储相应逻辑段的段基地址
d.指令指针寄存器：用于存储将要执行的下一条指令在现行代码段中的偏移地址
e.标志寄存器：用于寄存程序运行的状态信息

127.物理地址，段首地址，与偏移地址：
偏移地址就是在内存分段后，在段内某一地址对应段首地址的偏移量，物理地址是由对应的段基地址加上偏移地址组成的

128.const的用法：
a.定义不变的变量
b.在类的成员函数后加为这个函数不能改变类的成员变量，在前加为返还值是固定的
c.const与引用连用，防止原始值被改变

129.异步会造成什么后果：
同步优点为安全，缺点为每次都要判断锁，降级了效率
异步的优点为不需要判断锁，在访问资源的而空闲等待时同时访问其他的资源，速度快，缺点为不够安全，可能死锁

130.网络协议为什么要进行分类：
a.保证了各层之间的相互独立性，某一层并不需要知道它的上一层或下一层是怎么实现的，降低了复杂性
b.灵活性好，当某一层发生变化时，这层以上或下层均不受影响
c.结构上易于分割，各层都能使用最合适的技术实现，避免了木桶效应
d.易于实现和维护，这种结构使得实现和调试一个复杂的系统变得易于处理
e.能促进标准化工作，每一层的功能与服务都提供了精确的说明，可随意替换其中的某一层

131.CPU的执行方式：
a.计算机启动，cpu执行引导代码，加载操作系统到引导区
b.操作系统接手控制，执行特定程序，将程序代码加载到内存之中，并将CPU计数器指定到该内存位置，让CPU从当前位置开始执行代码

132.常考linux操作：
查看文件内容 more less cat head tail
查看进程状态 ps -ef
查看cpu状态 top
查看占用端口的进程号 netstat -lantp | grep -i 1922
查看内存缓存 free
swap：当内存不够，将部分内存上的数据转移到swap空间上，这样就能避免系统崩溃(类似于windows中的虚拟内存)
netstat：检测网络信息常用工具 -t为查看tcp网络连接状态
lsof:列出系统打开的所有文件，一般跟filename连用为显示开启对应文件的进程, lsof -p pid(pid号)，其中pid为进程简写，命令为查找对应进程打开的所有文件，-i为显示所有打开的端口
grep:用于查找文件里符合条件的字符串
uptime：查看系统负载情况
ls -i:查看文件inode号

133.共享内存的实现原理：
同一块物理内存被映射到了A,B各自的进程空间，对于32位进程，同一进程最多可连接11个共享内存段，其中共享内存是所有进程通信中最快的，因为不需要额外的机制

134.线程私有资源：
a.线程ID
b.寄存器
c.栈

135.exit()和_exit()的区别：
exit()在调用exit系统之前要检查文件的打开情况，把文件缓冲区的内容写回文件，且eixt()在结束程序之前还要调用一些清除操作
而_exit()是直接结束程序，立即返还给内核

136.connect的作用
tcp调用connect可以引起三次握手
udp调用connect第一可以指定新的连接，第二可以断开之前的连接

137.connect会阻塞，怎么解决?
改变成非阻塞模式，再不断用select检测状态

138.怎么判断socket可读与可写：
可读：
a.套接字接受缓冲区字节大于等于缓存区低水位
b.接受了FIN的TCP连接
c.该套接字是一个listen的监听套接字且连接数不为0
d.有一个错误套接字待处理
可写：
a.套接字接受缓冲区字节大于等于缓存区低水位
b.接受了FIN的TCP连接
c.使用非阻塞的connect套接字已经建立连接
d.有一个错误套接字待处理

139.设计模式分类：
创造型模式，结构型模式，行为型模式，并发型模式，线程池模式

140.常见的网络加密方式：

a.密钥散列：MD5加密，原理为，同时传输密文摘要与明文，再接收端将明文进行MD5编译，如果不同，则说明操作不安全并驳回
优点：可以防止篡改    缺点：不具备安全性和可认证性

b.对称加密：DES加密，原理为在客户端加密传输至服务端后再解密
优点：具有安全性和可认证性   缺点：网络传输过程中密钥过多难以维护

c.非对称加密：RSA加密，原理为，首次通行客户端接受了服务端的公钥，在后续传输中，客户端用接收端公钥加密，再在服务端用私钥解密

d.数字签名，适用于登录认证，但是不具备足保密性

141.构造函数为什么不能是虚函数：
简单来说就是没有意义，虚函数的作用在于通过父类的指针来调用子类的某个成员函数，而构建函数是在创建对象时自主调用的，不可能通过父类指针去调用或引用

142.对于简单类型，可以用free代替delete，但如果是类指针，就必须用delete，因为free不会执行类的析构函数

143.反向传播算法：引入Ω，Ω理解起来就是网络中前面一层某一个神经元对于loss的影响与该层的后一层所有的神经元对loss的影响、对应神经元的权重与该层的输出，并且所有神经元累加的一个效应。
从后往前计算出每一层神经元对损失值的影响，首先利用公式求出最后一层Ω的值，反向传播，可以求出每一个Ω的值，
根据Ω的值就可得到总误差和每一层权值的损失函数与偏导，接着只需利用好梯度下降不停训练权值，直至梯度值为0，即为误差函数的极值，达到最理想状态


144.linux下各类同步机制：a.锁机制 b.互斥 c.等待队列 d.关闭中断，异步机制为信号，信号主要用于用户空间进程和内核进程的交互

145.linux任务调度机制：
policy,priority,counter,rt_priority，这四项就是调度程序选择进程的依据，第一个为进程调度策略，第二是优先级，第三个是进程剩余时间片，第四个是实时优先级
其中policy分为 SCHED_OTHER，分时调度策略
SCHED_FIFO，实时调度策略，谁先到先服务谁
SCHED_RR，实时调度策略，与FIFO的不同为保证了所有具有相同优先级的进程的调度公平

146.10G 个整数，乱序排列，要求找出中位数。内存限制为 2G：
a.分为256M个段，刚好适配于2G，一个64位无符号数刚好是8B
b.统计每段的数，并计算出中位数所在段
c.遍历一次10G整数，将在段中的整数提取出来，并计算此段之前的整数的和
d.对此段进行排序，找出第5G和5G+1的数，即可以获得中位数

147.最长升序子串：
resultLen[0]=1；
for (int i = 1; i < seq.length(); ++i){ //每次循环算出一个resultLen
        resultLen[i] = 1;
        for (int j = 0; j < i; ++j){ //遍历之前已经算出的resultLen数组
            if (seq[i] >= seq[j] && resultLen[i] < resultLen[j] + 1){
                resultLen[i] = resultLen[j] + 1;
            }
        }
    }

148.5层协议中各层的作用：
应用层：让浏览器发生效果，让web应用成为显示
传输层：解决了客户端到服务端的传输服务，解决了网络层的丢包，失效等问题
网络层：实现了冲出局域网，全世界联网，ip寻址，主要作用域广域网，定位网络地址，通过APR协议可以转换为MAC地址
链路层：基于物理层封装成帧，MAC寻址，定位网络设备的逻辑地址
物理层：通常为电磁波，或传输电缆

149.广播风暴：
当网络规模过大，机器数量过多时，交换机就需要足够大的MAC地址表来记录MAC地址，这个表是通过广播包来收集到的，很可能造成广播风暴，
这就是利用ip地址的优点，它能将广域网分割成多个局域网，实现了广播包的隔离，有利于网络的稳定
广播风暴故障即一个数据包或帧被传送到本地网络上的每个子节点即为广播，但如果网络上的广播帧被突然频繁的转发，就会造成正常网络的异常现象

150.多线程实现原理：
主要是CPU通过给每个线程分配CPU时间片来实现多线程的。而线程比进程快底层是线程切换时间片速度快，而进程是要切换地址空间

151.10亿个扣扣号，每秒有10万条请求查询过来，如何处理：
消息队列削峰，缓存查找，数据库集群(用两台或多台服务器来构成一个虚拟单一的数据库对象，起到了负载均衡的作用)
负载均衡就是将工作任务进行平衡，分摊到多个操作单元上运行
集群与分布式的区别：分布式是将不同的业务发送到不同地方分开执行提升效率，而集群是指将多个服务器集中在一起实现同一业务

152.进程在内存中的结构：
栈，堆，未初始化全局变量，初始化全局变量，代码区

153.前序遍历树转链表
Node *last=NULL;
void change(Node *p){
    if(p==NULL) return;
    if(last!=NULL){
        last->left=NULL;
        last->right=p;
    }
    last=p;
    Node *temp=p->right;
    change(p->left);
    change(temp);
}

154.网络标识：
在不同的网络有不同的网络标识，数据链路层为mac地址，网络层为ip地址，传输层就是TCP或UDP的端口号

155.TCP传输过大文件思想：
a.客户端将大文件分成小包
b.服务端同意后，客户端发送第一个小包，包括文件名称，大小，发送小包的对应id与内容
c.服务端接收后，根据文件大小建立对应内存的数组，并将小包内容依次放入数组的对应位置

156.然后就是千万的数据求前100个最大重复的：
先用两个哈希表求出每个数据的数目，然后维护100个元素的小顶堆

157.序列化是将对象的状态信息转化为可存储或传输的对象的过程

158.线程池：
使用线程池可以很好的提高性能，线程池在系统启动时即创建大量空闲的线程，当程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，
执行完成后，该线程并不会死亡，而是返回线程池，等待下一个需要执行的命令

159.判断一个数是否是2的n次方：
执行n & (n-1) 时，n从右往数，第一个1变成0，其后所有数取反，所以如果是2的n次方，只能在对应位数为1，其余位都为0，所以n & (n-1) 每个位将不会有相同的数，将必然等于0

160.带优先级的括号匹配：
a.连续嵌套的特殊情况判断
b.优先级判断
c.栈判断是否能pop空

161.并行与并发的区别：
并行的意思是同一时刻多进程同时运行的现象，但对于单核CPU来说，同一时刻只能运行一个进程，而并发是多个线程被一个CPU轮流切换着运行，同时存在知识上下文切换速度过快造成的假象

162.大数据去重或求值：
一层哈希表分文件，比如分到100个小文件中，hash%100，二重哈希再去重或求值

163.一致性哈希算法：
在设计计算机分布缓存系统时，当某一台服务器失效时，如果不使用合适的算法来保证整个系统的一致性，那么所有数据都会失效
客户端在请求数据时，需要重新计算哈希值，由于哈希值已经改变，很可能找不到正确的服务器，所以哈希一致性非常重要
在一个虚拟的圆上，存储对应哈希值与服务器在2的32次方的圆上，当客户端请求数据时，从对应哈希值顺时针寻找，定位第一台服务器即使对应服务器
假设A,B,C,D对应NODE A,B,C,D，若NODE C出错，其余三个节点不影响，C被重新定位到NODE D,若一台机器不可用，受影响的仅仅是此服务器到逆时针前一台服务器之间的数据

164.
create table A if not exist {

id, int(3), not null, primary key;

name, varchar(20), not null;

sex, tinyint(1);

}

165.
sizdof("xyz\034")=5 sizeof("xyz\034"+1)=8,字符串加int转换为double，字符加int转换为int

166.主机序和网络序：
主机序：不同的CPU有不同的字节序类型，这些字节序指的是整数在内存中保存的顺序，这个叫主机序，分为两种
little endian：将低序字节存储在起始地址  big endian：将高序字节存储在起始地址
网络序：网络序是TCP/IP规定好的一种数据的表示形式，与CPU和操作系统都无关，保证了数据在不同主机中的传输能被正确的破解

167.硬链接与软链接：
在Linux中，数据被分为用户数据与元数据，用户数据存的是真实内容，而在元数据中inode号才是文件的唯一标识而非文件名(inode是元数据中的一部分，但不包括文件名，真正存储数据地址的节点)
硬链接删除会删除文件，软链接不会
硬链接：若一个inode号对应多个文件名则称这个文件为硬链接，换言之，就是一个文件使用了多个别名
软链接：软链接与硬链接不同，若文件用户数据块中存放的内容存放的是另一个文件路径名的指向，则该文件就是软链接

168.TCP粘包：
粘包原因：
a.发送端连续发送数据，多个小内容拼乘大内从容造成粘包
b.服务端接收buffer_size太小，不能一次接受所有内容，导致下次请求到达时，依然再接受上次的内容造成了粘包
解决方法：
a.加多recive的数量，防止连续发送的情况
b.发送端在发送前告知服务端发送内容的大小

169.http 1.0和http 1.1:
前者默认为非持久连接，后者默认为持久连接，在非持久情况下，一个TCP只能传输一个web对象，而持久可以传输多个对象

170.存活时间:
cookie默认存活时间是-1，即当浏览器关闭时cookie就消失，而session默认最大存活时间是30分钟

171.集群环境下如何保证数据的一致性：
主从复制，和数据同步

172.服务器集群以后如何做到数据的共享：
共享存储(多个服务器共用一个主存储器)，或者zookeeper(先选取leader,然后再根据leader同步数据)

173.TCP的流水线传输：
流水线的原理为TCP网络能连续发送多个数据段，而不需要等待先前发送的数据段被确认，增加了效率

174.http状态码：
200:正常
400.客户端问题
500.服务端问题
301.当客户端的操作引起了资源url的变化时发送此响应代码(300一般跟重定向有关)

175.PCB是进程控制块，
其中包括1.mm：进程的内存 2.fs：根路径和当前路径指针 3.files：进程打开的文件 4.signal：信号资源 5.pid：进程的属性资源
 
176.struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。

177.一般使用的scoket都是阻塞同步的，libevent是一些高效I/O的封装(例如epoll)，提供统一的API(一些预定好的函数)，简化开发
过程：
创建一个event_base来监听一个fd,定义监听的fd,回调函数,超时时间来对，并用event_add来启用
创建一个event，将该socket托管给event_base，指定监听类型，并绑定对应的回调函数
开启循环直至不再有需要关注的事件
当有client发起请求的时候，调用这个回调函数，进行处理
注意：当使用回调函数recv读入数据后，不可直接send丢给socketfd，因为可能造成阻塞，正确方法为，改为非阻塞再重新创一个event来托管这个socketfd
等待event_read事件的发生，调用响应回调函数,不可直接丢给scoketfd，创建缓存来保存读入的数据，在合适的事件再启用event_write,往socketfd中写数据，结束后再删除event_write

178.MySQL的主从复制：
a)主服务器的任何修改都会通过I/O线程写进bin-log文件中
b)从服务器也开启一个I/O线程并连接到主服务器，读取bin-log中数据并写入本地的realy log里面
c)从服务器同时开启一个SQL线程不断检查realy log，如果发现有更新，则把更新内容在本地服务器上执行一遍

179.tf.session是为了控制和输出文件的执行语句 session.run执行输出结果

180.JAVA与C++区别：
a.C++在源代码级具有一定程度的平台无关性，而JAVA是依靠JVM，在目标代码级实现了平台无关
b.c++采用单线程系统，而JAVA引入了多线程的支持
c.出于安全角度考虑，JAVA删除了C++中指针和多继承的概念，只能进行单继承，但却引入了接口的概念

181.n>>(31-i)&1得出的数值即为从左往右数第i个位上的值，二进制的颠倒，(((n>>(31-i)) & 1) << i) 所做的操作就是取出的第i位从右往左移动i位，在对每位颠倒取或即为正确值：
unsigned int reverse(unsigned int num)
{
    unsigned int ret=0;
    for(int i=31;i>=0;i--){
        ret=ret|(((num>>(31-i))&1)<<i);        
    }
    return ret;    //TODO:
}

182.递归中用string记录路径时要加char，ss+char('A'+i)

183.迭代器不是指针，是类模板，表现得像指针，可以理解为更高级的指针

184.给定一个字符串，找出不含有重复字符的最长子串的长度。
while (i < s.length() && j <s.length() ) {
            if(hash[j] == 0) {
                hash[s.charAt(j)] = 1;
                j++;
                count=max(count,j-i);
            } else {
                hash[i] = 0;
                i++;
            }  
        }
return count;

185.ip数据报文必须封装成帧才可以通过物理网络发送，因此还需要知道mac地址(物理地址)，从而保证数据报文的顺利传送
mac地址在链路或局域网中标识不同的节点(物理地址与数据链路层地址)，一般固定在网络设备中，而ip地址在整个网络中标识不同的节点(网络层地址)

186.ARP协议分为动态ARP和静态ARP，动态ARP由ARP协议通过APR报文自动生成和维护，可以被老化，可以被新的动态ARP表项更新，特可以被静态ARP表项覆盖
静态ARP表项由网络管理员手工配置生成和维护，不会老化，也不会被动态ARP表项覆盖
每个主机都具有ARP缓存表(可减小ARP操作，增加网络性能) ARP缓存表中有mac地址时，不会调用ARP请求报文查找对应ip地址所对应的mac地址，反之在没有时，才会调用ARP请求报文，将ip地址与mac地址的对应关系存在在ARP缓存中
当发送端ip地址与目的ip地址在同网段时，发送端向接收端发送ARP请求报文，接收端以单波形式返还对应mac地址，如果在不同网段，则要先请求网关mac地址，再请求接收端mac地址

187.免费ARP：免费ARP通过广播方式通告自己的地址信息(1.可不断获取mac地址 2.可检测ip冲突)

188.路由器与转换器：转换器一般用于同网段之间的数据传输
路由器又可以称之为网关设备。路由器就是在OSI/RM中完成的网络层中继以及第三层中继任务，对不同的网络之间的数据包进行存储、分组转发处理，其主要就是在不同的逻辑分开网络。而数据在一个子网中传输到另一个子网中，可以通过路由器的路由功能进行处理。

189.ip地址分为网络部分和主机部分(由32位二进制数组成，分为4段，每段转换成10进制)，icpm协议是网络层的一个组成部分，常用来传递差错，控制，查询报文等信息(ping,tracert)

190.子网掩码，网络部分为1，主机部分为0，如(255.255.255.0)，将ip地址与地址掩码进行与操作，即可获得改地址段的网络地址(主机部分全为0，广播地址主机部分全为1)

191.数据在不同链路上传输时，源和目的mac地址变化，而源和目的ip地址不发生变化

192.路由分为静态路由，动态路由，缺省路由，策略路由
动态路由协议分为距离适量协议和链路状态协议(使用dijkstra算法)
距离矢量协议(动态路由协议)：每个路由器维护着一个距离矢量表，记录着到达目的节点的最佳路线，与到达目的节点所需要的距离与时间
当形成环路或连接断裂时，就会出现无穷计算的问题，为了避免无穷计算，一般有两种解决办法
1.设置最大mertic为15跳，大于15跳即为网络不可到达，这种方法使RIP(动态路由协议)只能应用于中小网络
2.水平分割技术，路由器不会再向邻居返回一个从该邻居获取的最短路径

193.当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
NAT实现方式：1.静态NAT 2.动态NAT 3.实现端口的多路复用，即多个局域网地址对应一个公网地址，提高了ip地址的利用率

194.ipv6的地址解析过程：
1.判断是否需要进行地址解析过程：查找每个节点的邻居缓存，如果存在对应ipv6与mac地址，则直接使用
2.当需要地址解析时，发送节点发送邻居请求(NS)：组播发送，包含要解析的ipv6地址
目标节点接收NS并处理NS，响应邻居公告(NA)，单波发送，包含目标节点mac地址
发送节点更新邻居缓存

195.衡量网络的四个指标：
吞吐，时延，新建，并发
新建与并发不同的是新建连接测试会立即结束建立的连接，而并发测试不会结束建立的连接，所有已建立的连接会一直保持直到设备的处理极限(重点为需要保持)

196.RFC2544(netperf)测试指标：吞吐量，时延，丢包率，背靠背，系统恢复，复位测试

197.网络排查步骤：
1.首先ping目标ip看看是否能ping通，观察ip返还的结果是否为destination host unreachable
2.在机器后台可以通过ifconfig和ip link查看网络网口的状态是否为up状态
3.如果网口状态已经是up状态，利用ifconfig和 ip addr命令查看网口ip与掩码是否正常
4.若网口ip与掩码正常，但却无法ping通，可以使用ip route命令查看路由表配置是否正常

198.网络排障工具：
ifconfig,ping,ethtool(查看网卡特性),ICMP(ping,tracert),tcpdump(抓包工具),wireshark,netflow,ipfix

199.SDN的三大特点：控制与转发分离 集中式的管理 开放可编程

