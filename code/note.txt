1.自我介绍

2.介绍一下简历里的项目

3.char * 和char[]的区别:
a.一个为指向字符型的指针，一个为存储多个字符型的数据结构，当使用第一个定义一个字符串时，*p指向首字符地址
b.第一个可以在堆上构建与释放
c.第一个在编译时赋值，后期不能进行改变，另一个可以改变

4.初始化列表的初始化顺序,问下列代码的输出顺序;
按private定义顺序来赋值，不定义默认为16位二进制数最大值，32767

5.讲一下指针：
指向一个目标值的地址，利用指针，能指向存储在电脑储存器另一个地方的值

6.指针和数组的区别：
a.同类型指针能相互赋值，数组只能一个个赋值或拷贝
b.数组的存储空间不是在栈上，就是在静态区上，指针可以在堆上开辟空间，也可以指向其他区域的空间
c.定义不同，第一个位指向一个类型的地址，另外一个数存储定义类型的数据结构
d.sizeof不同

7.说一下指针和引用的区别：
a.指针是一个实物对象，实际存在的，引用只是一个取地址的别名
b.指针指向值后可改变，引用不可以
c.指针可以指向NULL，引用不行
d.程序需要为指针分配内存，引用不用
e.指针编译时，在符号表上显示的地址值为指针的地址值，而引用为对应值的地址
f.引用只有一级，指针可以为多级
g.引用必须初始化，指针不用

8.一个空类有那些函数：
构造函数，析构函数，拷贝函数和赋值构造函数

9.拷贝构造函数，赋值构造函数分别什么时候调用，写一下拷贝构造函数，赋值构造函数的声明
A a；
A b=a；第一个
A c；
c=a；第二个

string(const string& a){
	store=new char[a.len];
	for(int i=0;i<a.len;i++){
	store[i]=a.store[i]; }
}

string& operator=(const string& a){
	string copy(a);
	this->len=copy.len;
	swap(this->store.copy.store);
	return *this;
}

10.讲一下TCP/IP模型,TCP协议在那一层
TCP/IP模型定义了当代网络的所有基本协议，分为应用层，传输层，网络层和网络接入层
TCP定义了面向连接的，可靠的一种传输层的通信协议，IP协议只要用与在源地址和目的地址传输数据包，他还提供了对数据大小的重组装功能已适应不同的网络环境

11.HTTP协议的头有什么，说几个常用的：
Request header:

accept:向服务端声明客户端可以接受的资源类型
accept-encoding:向服务端声明客户端可以使用的编码方法，通常为压缩方法
Cache-control:控制浏览器的缓存
cookie:告诉服务器session的信息，存储让服务器辨识用户的信息
refer：告诉服务器该页面是从哪个页面链接的

Response header:

accept-range：表明自己是否已经接受了实体的一部分
content-length:设置http实体的传输长度
content-encoding:设置数据使用的编码类型
Age/date/expire：设置响应体的寿命，创建日期和过期日期

12.Session和Cookie的区别是什么：
cookie作用于用户计算机上，用来维护计算机中的信息，直到用户删除
session称为会话信息，作用于服务器，用于访问者与网站的交互
a.cookie以文本格式存储在浏览器中，而session存储在服务端
b.cookie限制了存储量，而session无限
c.可读取cookie信息，但session不行，更加安全

13.TCP的三次握手和四次挥手，如果改成两次握手会怎么样
请求会话一次，收到回话反问一次，答复反问一次，才开始会话
如果改成两次，若出现意外情况，会使B方一直等待，浪费时间
断开连接为四次挥手：
-客户机：服务器，我想和你断开连接，你同意吗？（FIN=1）
-服务器：我同意（ACK=1）
-服务器：客户机，我想要和你断开连接，你同意吗？（FIN=1）
-客户机：我同意。（ACK=1）
再等待2MSL时间后就真正断开了连接：1.防止最后发送的信号丢失 2.防止失效文段出现在本文本中，使下个新连接不会出现旧字段。

14.讲一下TCP和UDP的区别，什么时候应使用哪个协议，UDP的优点是什么
TCP面向连接的，更加稳定的传输层的通信协议
UDP面向非链接的传输层的通信协议
TCP：TCP对系统资源要求更多，需要维护连接状态，但是更加稳定，基于流的
UDP：不需要维护连接状态，程序结构简单，但可能丢包，基于数据报文

15.讲一下线程与进程的区别

a.进程为资源分配最小单位，线程为资源调度最小单位
b.每个进程有独立的空间，而线程为多线程公用一个空间，所以切换线程开销更小
c.线程通信方便，公用全局变量和静态变量
d.进程更稳定，线程一个崩了就全崩了

16.线程的同步方式有哪些，什么时候使用线程，应该开多少线程，线程数量由什么因素决定

a.通过object的wait和notify
b.通过condition的await和signal
c.通过一个阻塞队列
d.通过两个阻塞队列
e.通过同步队列
f.通过callback回调
g.通过同步辅助类CountDownLatch
h.通过CyclicBarrier

多核cpu，防止阻塞，便于建模

最佳线程数=((线程等待时间+线程CPU时间)/线程CPU时间）* CPU数目

17.写一个链表反转函数
void reverse(Node *pHead){
	Node* temp=NULL;
	Node* next=NULL;
	while(pHead!=NULL){
	   next=pHead->next;
	   pHead->next=temp;
	   temp=pHead;
	   pHead=next;
	}
	return temp;
}

18.对数据库有了解吗，Mysql数据库的数据库有哪些索引
普通索引
唯一索引
主键索引:唯一且不为空值
组合索引

19.malloc和new区别

a.malloc和new都在堆上分配空间，但new会自动初始化
b.malloc使函数返回void*，需要强制转换类型。new为运算符，输入数目
c.malloc开辟失败返回NULL，new会抛出异常
d.malloc通过free，new通过delete
e.malloc只有一种，new有new const new,nothrow版本的new，定位new

20.
Countdownlatch:等需要等待的线程都进行完了，再执行这个线程
cyclicbarrier:等所有线程准备完毕进入await再一起执行

21.c++实现线程同步：
c++可以通过thread类实现线程同步
通过join函数或sleep可使子线程在主线程之前之前，join会造成子线程对主线程的阻塞
通过detach可使子线程重主线程中分离，彼此互不干扰

22.原子变量:
在c++11中引入了原子变量的概念，并定义了多种原子操作数据类型，例如atomic_bool,atomic_int等等，如果我们在多个线程中对这些共享资源进行操作，编译器将保持这些变量的原子性，也就是说确保任意时刻只有一个线程对这个资源进行访问，保证了共享资源的正确性，避免的锁的使用，从而提升了效率

23.智能指针：
智能指针分为auto_ptr,shared_ptr,weak_ptr,unique_ptr,其中第一个已经被c++11弃用了
为什么要使用智能指针？
众所周知，指针的内存管理非常麻烦，当new创建后，需要自己写delete语句，但是我们不能避免程序未到delete就跳转了或自动返回了，如果我们不在每一个跳转或返回之前释放资源，就会造成内存的泄露，使用智能指针就能解决这个问题，因为智能指针本身就是一个类，当超过了类的作用域，类会自己调用析构函数
智能指针的操作：

auto_ptr<Test> ptest(new Test("123"))：
1.获得原指针为 ptest.get() 2.重新指向为 ptest.reset(new Test("456")) 3.判断是否为空为ptest.get()==NULL, 4.使用release可以将指针赋值为空，但不调用析构函数释放内存，只是释放了资源

unique_ptr<Test> ptest(new Test("123"))：
1.不能直接调用拷贝函数和赋值操作(即不能指向同一个对象)，只能使用 ptest2=std::move(ptest),即一个提醒用户原来的函数已经失效; 2.增添swap可交换两个智能指针的值 3.其他于auto_ptr类似

share_ptr<Test> ptest(new Test("123"))：一个对象可被多个智能指针所共享
1.当ptest=ptest2时，ptest2不会置为NULL，此时456被两个智能指针同时共享 2.通过ptest2.use_count()，可看出该指针的指向被几个指针共享

weak_ptr<Test> ptest(new Test("123"))：用于解决share_ptr的相互引用(计数无法下降为0)

25.vector和list：
根据笔者推断有可能是由于stl的list是双向链表，所以这种push_back会涉及到内存的分配和列表关系的维护，所以导致时间开销大。但是实际上vector频繁的push_back，会使得预留空间不够的时候，重新申请空间导致的不必要的开销。

26.全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失，起到了分类器的作用

27.
拉链法优点：
1.处理冲突简单，不同义词不会有堆积现象，平均查找长度较短
2.拉链发指针空间动态申请，适用于表长不确定的情况下
3.开放地址需要很大的装填因子(结点数和表长的比值)，容易出现空的空间
4.删除方便，开放地址法不能直接删除，会截断后面的同义词的查找路径
拉链法缺点：
指针需要额外的空间，若结点数目少，贼耗费空间

28.进程与线程的同步通信方式
进程：无名管道，有名管道，信号，信号量，共享内存，消息队列和socket
线程：互斥量，读写锁，自旋锁，线程信号，条件变量

29.TCP连接中。socket在服务端和客户端分别要做什么？
socket为套接字，为通信链的句柄，分为流式套接字，数据报套接字。原始套接字，只有对方和自己的socket连接才能传递信息
服务程序：用socket()建立套接字，调用bind()绑定ip地址与端口，然后启动一个死循环，循环中用accept()接受连接，对于每个接受的连接，可以使用send()或recv()函数收发数据
客户端：用socket()建立套接字，然后调用connect()连接服务器，之后再调用send()和recv()收发数据

30.虚函数和纯虚函数:
虚函数可以直接使用，也可以在重载或以后以多态的形式调用，纯虚函数在基类中没有实际定义，必须在子类中加以实现，且具有纯虚函数的抽象类不能进行实例化
虚函数效率低的原因：需要一次间接寻址，一般函数在编译时能直接定位地址，虚函数需要某个指针才能定位到函数的地址

31.虚析构函数:
当使用父类指针指向子类的对象时，只会调用父类的析构函数，但若定义了父类的虚析构函数，就会同时调用子类和父类的析构函数，避免了内存的泄露

32：哈希表的长度取决于散列函数和冲突解决的策略，一般最合理的为存在键数的1.3倍

33.extern放在函数或变量之前时，表示变量或函数的定义在别的文件中，提示编译器遇到此模块时在别的模块中寻找其定义
与c连用时告诉编译器用C的规则去翻译
static只在本文件中使用
extern可被其他文件使用
一个被定义了volatile的变量相当于告诉这个编译器变量经常会被意想不到的改变，当使用这个变量时，必须从它对应的地址中读取信息，而不是使用保留在寄存器中的备份

34.僵尸进程:如果子进程比父进程先结束，但父进程却没有及时回收子进程，造成了资源的泄露，此时子进程就成了一个僵尸进程
解决方式：调用wait使父类进程等待它
用signal通知内核，并让内核对其进行回收

35.自旋锁与互斥锁都可用来通知多线程，每次只有一个线程能对此变量进行操作，区别是，互斥锁为锁定其他的互斥量，其他互斥量睡眠等待被唤醒，使用自旋锁，其他线程保并不会睡眠等待，而是不停的循环检测保持者是否已经释放了锁

36.ResNet:
网络深度越高，对特征的的表达能力越高，如果不考虑梯度弥散或爆炸，准确率将会越高
一个方面，改变成计算FX的值，当网络特征达到optimal时，FX自动退化成0，能够实现恒等映射的作用
残差块的值会减小模块中参数的值，从而使网络堆反向传播的损失具有更加敏感的响应作用
因为有恒等映射支路的存在，反向传播中梯度的传到也变得更为快捷，仅仅通过relu一个激活函数，就可把梯度传给上一个模块
但太深也不行，残差模块在加后需要一个激活函数，当层数过多时，会阻碍整个网络的反向传播

37.
void* _memcpy(void* dest, const void* src, size_t count)
{
	assert(src != nullptr&&dest != nullptr);
	char* tmp_dest = (char*)dest;
	const char* tmp_src = (const char*)src;
	while (count--)
		*tmp_dest++ = *tmp_src++;
	return dest;
}

void* _memmove(void* dest, const void* src, size_t count)
{
	assert(src != nullptr&&dest != nullptr);
	char* tmp_dest = (char*)dest;
	const char* tmp_src = (const char*)src;
	if (tmp_src > tmp_dest)//当src地址大于dest地址时，从头进行拷贝
		while (count--)
			*tmp_dest++ = *tmp_src++;
	else if (tmp_src > tmp_dest)//当src地址小于dest地址时，从后进行拷贝
	{
		tmp_src += count - 1;
		tmp_dest += count - 1;
		while (count--)
			*tmp_dest-- = *tmp_src--;
	}
	else(tmp_src==tmp_dest) //此时不进行任何操作
	return dest;
}

38.I/O 多路复用;
一个进程能处理多个网络连接的IO，它的基本原理是select,poll,epoll这几个函数会轮流负责所有的socket，当某个socket有数据到达，就通知用户进程

39.gdb:
如何查看某个线程: info thread
如何设置断点:break n
如何跳入下一下：next

40.内存耗用:
VSS:虚拟内存
RSS:实际使用物理内存，包括共享库内存
PSS:实际使用的物理内存，但共享库内存按照线程数进行了划分
USS:进程独占内存

41.C4.5	决策树：
以信息增益率代替了信息增益成为了树枝的划分条件
寻找每个非叶子节点的损失函数减小程度，选取最小的进行剪枝，得到n个不同的剪枝树，使用交叉验证，选取最优子树
剪枝的目的并不是为了最小化损失函数，而是为了增加泛性，损失函数越小，越准确，泛性越弱

42.
select、poll、epoll之间的区别
select:O(n) 无差别查询所有数据流
poll:与select相似，但没有最大连接数的限制，链表结构
epoll:O(1) epoll会把，哪个流发生了怎样的I/O事件通知给我们

43.this指针：
1.this指针本质上是一个函数的参数，只不过在编译器隐藏起来了，只能在成员函数中使用
2.this在成员函数开始前构造，在结束后自动删除
3.this指针不占用对象的空间

44.ifndef/define/endif的作用：
防止头文件被重复的使用或定义

45.c和c++：
C主要考虑通过一个过程将输入进行各种运算后得到输出，C++主要考虑的是如何构造一个对象模型

46.堆栈溢出原因：数组越界，死循环，没有回收内存，深层次递归调用

47.普通局部变量与局部静态变量的区别：
1.普通局部变量是执行到定义语句才会分配空间，static在编译器分配空间
2.普通局部变量在离开对应作用域释放，第二个在整个函数结束后才会释放
3.普通局部变量不初始化为随机值，另一个为0

48.内联函数和宏的区别：
内联函数若系统判定为可以内联，他就会在编译阶段直接展开并镶嵌到代码之中。
宏不是函数，他只是在编译期预处理阶段将函数中对应的字符串替换成了宏体
const相比于宏，前者可以定义数据类型，更加安全，而后者不行，但后者在运行时不必分配内存

49.快慢链表：
1.判断是否有环：在NULL之前判断快慢指针是否相遇
2.判断环长度:从碰撞点出来，再次相遇时，慢指针走过的距离即为长度
3.判断环的连接点，速度相同的指针分别从碰撞点与头节点遍历，相遇点即为连接点

50.
重载为函数名相同，参数类型，数量不同，与多态无关，重写才与多态有关

51.拷贝构造函数和赋值函数：
浅拷贝：只拷贝目标的指针，而不复制对象本身，新旧对象共用同一块地址
深拷贝：创造一个和原来一摸一摸的对象，新旧对象不共享地址
拷贝构造函数：对象不存在，且用别的对象对其进行初始化。在不自己定义时，会默认为浅拷贝(同一片内存会被释放两次，会导致程序崩溃)，需要自己进行重载成深拷贝(完成独立成两个对象，指向不同的地址)
赋值函数：对象已经存在，且用别的对象对其进行赋值。

52：设计模式是一套经过反复调用与实验的代码设计经验的总结
单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点
工厂模式：定义一个创建对象的接口，并让子类决定实例化哪一个类

53：STL主要包括三部分，容器，算法和迭代器：
容器分为序列式容器(list,vector)和关联式容器(tree,map,hashmap)
算法一般为排序，查找，最短路径
迭代器提供了一种方法，使它能够给顺序访问某个容器所包含的所有元素，但无需暴露该容器的内部结构

54.strstr(str1,str2)判断str2是否为str1的子串，并返还str1中第一次出现str2的地址,&str1[i],strcat(str1,str2)为将str2补充到str1的后面

55.strcpy与memcpy的不同：
1.复制内容不同，strcpy只能作用于字符串，而memcpy能作用于任何数据类型
2.strcpy他遇到被复制的字符串的'\0'才结束，所用容易溢出，memcpy则是根据第三个参数决定
3.用处不同，一般字符串用strcpy，其他类型用memcpy

56.C#委托和事件的区别：
委托是一个类，该类内部维护着一个字段，指向一个方法。事件可以看作一个委托类型的变量，通过事件可以注册或取消多个委托或方法

57.i++是否为原子操作：
在多线程中，不能被其他线程打断的操作就叫做原子操作
i++分为三个阶段：内存到寄存器，寄存器自增，写回内存，这三个阶段都可以被其他线程打断或分离开

58.c++的四种强制类型转换：
static_cast:可以实现基本数据类型的转换
const_cast:可以将不是const的数据类型转换成const
reinterpret_cast:可以进行任意数据类型的转换，但不考虑安全情况
dynamic_cast:
1.在运行时完成，其他都在编译时完成，运行时要进行类型检查
2.不能用于内置的基本的数据类型的转换
3.成功转换后返还指向类的指针与引用，转换失败会返还NULL
4.转换基类一定要有虚函数，不然失败
5.一般用于父类到子类的转换，有自动检查功能，安全

59.#pragma pack(n)可设置字节对齐方式，n为字节对齐数

60.auto_ptr缺陷：
1.两个智能指针不能指向一个对象
2.auto_ptr不能管理对象数组，因为析构函数是delete而不是delete[]
3.auto_ptr不能作为容器对象，因为在容器拷贝赋值等操作中，在这过程中auto_ptr会传送所有权
